/* automatically generated by rust-bindgen 0.66.1 */

pub const NVML_API_VERSION: u32 = 12;
pub const NVML_API_VERSION_STR: &[u8; 3] = b"12\0";
pub const NVML_VALUE_NOT_AVAILABLE: i32 = -1;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE: u32 = 32;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_V2_SIZE: u32 = 16;
pub const NVML_DEVICE_PCI_BUS_ID_LEGACY_FMT: &[u8; 17] = b"%04X:%02X:%02X.0\0";
pub const NVML_DEVICE_PCI_BUS_ID_FMT: &[u8; 17] = b"%08X:%02X:%02X.0\0";
pub const NVML_NVLINK_MAX_LINKS: u32 = 18;
pub const NVML_MAX_PHYSICAL_BRIDGE: u32 = 128;
pub const NVML_MAX_THERMAL_SENSORS_PER_GPU: u32 = 3;
pub const NVML_MAX_GPU_PERF_PSTATES: u32 = 16;
pub const NVML_GRID_LICENSE_EXPIRY_NOT_AVAILABLE: u32 = 0;
pub const NVML_GRID_LICENSE_EXPIRY_INVALID: u32 = 1;
pub const NVML_GRID_LICENSE_EXPIRY_VALID: u32 = 2;
pub const NVML_GRID_LICENSE_EXPIRY_NOT_APPLICABLE: u32 = 3;
pub const NVML_GRID_LICENSE_EXPIRY_PERMANENT: u32 = 4;
pub const NVML_GRID_LICENSE_BUFFER_SIZE: u32 = 128;
pub const NVML_VGPU_NAME_BUFFER_SIZE: u32 = 64;
pub const NVML_GRID_LICENSE_FEATURE_MAX_COUNT: u32 = 3;
pub const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_NO: u32 = 0;
pub const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_YES: u32 = 1;
pub const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_NO: u32 = 0;
pub const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_YES: u32 = 1;
pub const NVML_VGPU_SCHEDULER_POLICY_UNKNOWN: u32 = 0;
pub const NVML_VGPU_SCHEDULER_POLICY_BEST_EFFORT: u32 = 1;
pub const NVML_VGPU_SCHEDULER_POLICY_EQUAL_SHARE: u32 = 2;
pub const NVML_VGPU_SCHEDULER_POLICY_FIXED_SHARE: u32 = 3;
pub const NVML_SUPPORTED_VGPU_SCHEDULER_POLICY_COUNT: u32 = 3;
pub const NVML_SCHEDULER_SW_MAX_LOG_ENTRIES: u32 = 200;
pub const NVML_GRID_LICENSE_STATE_UNKNOWN: u32 = 0;
pub const NVML_GRID_LICENSE_STATE_UNINITIALIZED: u32 = 1;
pub const NVML_GRID_LICENSE_STATE_UNLICENSED_UNRESTRICTED: u32 = 2;
pub const NVML_GRID_LICENSE_STATE_UNLICENSED_RESTRICTED: u32 = 3;
pub const NVML_GRID_LICENSE_STATE_UNLICENSED: u32 = 4;
pub const NVML_GRID_LICENSE_STATE_LICENSED: u32 = 5;
pub const NVML_GSP_FIRMWARE_VERSION_BUF_SIZE: u32 = 64;
pub const NVML_DEVICE_ARCH_KEPLER: u32 = 2;
pub const NVML_DEVICE_ARCH_MAXWELL: u32 = 3;
pub const NVML_DEVICE_ARCH_PASCAL: u32 = 4;
pub const NVML_DEVICE_ARCH_VOLTA: u32 = 5;
pub const NVML_DEVICE_ARCH_TURING: u32 = 6;
pub const NVML_DEVICE_ARCH_AMPERE: u32 = 7;
pub const NVML_DEVICE_ARCH_ADA: u32 = 8;
pub const NVML_DEVICE_ARCH_HOPPER: u32 = 9;
pub const NVML_DEVICE_ARCH_UNKNOWN: u32 = 4294967295;
pub const NVML_BUS_TYPE_UNKNOWN: u32 = 0;
pub const NVML_BUS_TYPE_PCI: u32 = 1;
pub const NVML_BUS_TYPE_PCIE: u32 = 2;
pub const NVML_BUS_TYPE_FPCI: u32 = 3;
pub const NVML_BUS_TYPE_AGP: u32 = 4;
pub const NVML_FAN_POLICY_TEMPERATURE_CONTINOUS_SW: u32 = 0;
pub const NVML_FAN_POLICY_MANUAL: u32 = 1;
pub const NVML_POWER_SOURCE_AC: u32 = 0;
pub const NVML_POWER_SOURCE_BATTERY: u32 = 1;
pub const NVML_POWER_SOURCE_UNDERSIZED: u32 = 2;
pub const NVML_PCIE_LINK_MAX_SPEED_INVALID: u32 = 0;
pub const NVML_PCIE_LINK_MAX_SPEED_2500MBPS: u32 = 1;
pub const NVML_PCIE_LINK_MAX_SPEED_5000MBPS: u32 = 2;
pub const NVML_PCIE_LINK_MAX_SPEED_8000MBPS: u32 = 3;
pub const NVML_PCIE_LINK_MAX_SPEED_16000MBPS: u32 = 4;
pub const NVML_PCIE_LINK_MAX_SPEED_32000MBPS: u32 = 5;
pub const NVML_PCIE_LINK_MAX_SPEED_64000MBPS: u32 = 6;
pub const NVML_ADAPTIVE_CLOCKING_INFO_STATUS_DISABLED: u32 = 0;
pub const NVML_ADAPTIVE_CLOCKING_INFO_STATUS_ENABLED: u32 = 1;
pub const NVML_MAX_GPU_UTILIZATIONS: u32 = 8;
pub const NVML_FI_DEV_ECC_CURRENT: u32 = 1;
pub const NVML_FI_DEV_ECC_PENDING: u32 = 2;
pub const NVML_FI_DEV_ECC_SBE_VOL_TOTAL: u32 = 3;
pub const NVML_FI_DEV_ECC_DBE_VOL_TOTAL: u32 = 4;
pub const NVML_FI_DEV_ECC_SBE_AGG_TOTAL: u32 = 5;
pub const NVML_FI_DEV_ECC_DBE_AGG_TOTAL: u32 = 6;
pub const NVML_FI_DEV_ECC_SBE_VOL_L1: u32 = 7;
pub const NVML_FI_DEV_ECC_DBE_VOL_L1: u32 = 8;
pub const NVML_FI_DEV_ECC_SBE_VOL_L2: u32 = 9;
pub const NVML_FI_DEV_ECC_DBE_VOL_L2: u32 = 10;
pub const NVML_FI_DEV_ECC_SBE_VOL_DEV: u32 = 11;
pub const NVML_FI_DEV_ECC_DBE_VOL_DEV: u32 = 12;
pub const NVML_FI_DEV_ECC_SBE_VOL_REG: u32 = 13;
pub const NVML_FI_DEV_ECC_DBE_VOL_REG: u32 = 14;
pub const NVML_FI_DEV_ECC_SBE_VOL_TEX: u32 = 15;
pub const NVML_FI_DEV_ECC_DBE_VOL_TEX: u32 = 16;
pub const NVML_FI_DEV_ECC_DBE_VOL_CBU: u32 = 17;
pub const NVML_FI_DEV_ECC_SBE_AGG_L1: u32 = 18;
pub const NVML_FI_DEV_ECC_DBE_AGG_L1: u32 = 19;
pub const NVML_FI_DEV_ECC_SBE_AGG_L2: u32 = 20;
pub const NVML_FI_DEV_ECC_DBE_AGG_L2: u32 = 21;
pub const NVML_FI_DEV_ECC_SBE_AGG_DEV: u32 = 22;
pub const NVML_FI_DEV_ECC_DBE_AGG_DEV: u32 = 23;
pub const NVML_FI_DEV_ECC_SBE_AGG_REG: u32 = 24;
pub const NVML_FI_DEV_ECC_DBE_AGG_REG: u32 = 25;
pub const NVML_FI_DEV_ECC_SBE_AGG_TEX: u32 = 26;
pub const NVML_FI_DEV_ECC_DBE_AGG_TEX: u32 = 27;
pub const NVML_FI_DEV_ECC_DBE_AGG_CBU: u32 = 28;
pub const NVML_FI_DEV_RETIRED_SBE: u32 = 29;
pub const NVML_FI_DEV_RETIRED_DBE: u32 = 30;
pub const NVML_FI_DEV_RETIRED_PENDING: u32 = 31;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L0: u32 = 32;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L1: u32 = 33;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L2: u32 = 34;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L3: u32 = 35;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L4: u32 = 36;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L5: u32 = 37;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_TOTAL: u32 = 38;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L0: u32 = 39;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L1: u32 = 40;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L2: u32 = 41;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L3: u32 = 42;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L4: u32 = 43;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L5: u32 = 44;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_TOTAL: u32 = 45;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L0: u32 = 46;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L1: u32 = 47;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L2: u32 = 48;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L3: u32 = 49;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L4: u32 = 50;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L5: u32 = 51;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_TOTAL: u32 = 52;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L0: u32 = 53;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L1: u32 = 54;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L2: u32 = 55;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L3: u32 = 56;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L4: u32 = 57;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L5: u32 = 58;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_TOTAL: u32 = 59;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L0: u32 = 60;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L1: u32 = 61;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L2: u32 = 62;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L3: u32 = 63;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L4: u32 = 64;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L5: u32 = 65;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_TOTAL: u32 = 66;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L0: u32 = 67;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L1: u32 = 68;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L2: u32 = 69;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L3: u32 = 70;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L4: u32 = 71;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L5: u32 = 72;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_TOTAL: u32 = 73;
pub const NVML_FI_DEV_PERF_POLICY_POWER: u32 = 74;
pub const NVML_FI_DEV_PERF_POLICY_THERMAL: u32 = 75;
pub const NVML_FI_DEV_PERF_POLICY_SYNC_BOOST: u32 = 76;
pub const NVML_FI_DEV_PERF_POLICY_BOARD_LIMIT: u32 = 77;
pub const NVML_FI_DEV_PERF_POLICY_LOW_UTILIZATION: u32 = 78;
pub const NVML_FI_DEV_PERF_POLICY_RELIABILITY: u32 = 79;
pub const NVML_FI_DEV_PERF_POLICY_TOTAL_APP_CLOCKS: u32 = 80;
pub const NVML_FI_DEV_PERF_POLICY_TOTAL_BASE_CLOCKS: u32 = 81;
pub const NVML_FI_DEV_MEMORY_TEMP: u32 = 82;
pub const NVML_FI_DEV_TOTAL_ENERGY_CONSUMPTION: u32 = 83;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L0: u32 = 84;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L1: u32 = 85;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L2: u32 = 86;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L3: u32 = 87;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L4: u32 = 88;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L5: u32 = 89;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_COMMON: u32 = 90;
pub const NVML_FI_DEV_NVLINK_LINK_COUNT: u32 = 91;
pub const NVML_FI_DEV_RETIRED_PENDING_SBE: u32 = 92;
pub const NVML_FI_DEV_RETIRED_PENDING_DBE: u32 = 93;
pub const NVML_FI_DEV_PCIE_REPLAY_COUNTER: u32 = 94;
pub const NVML_FI_DEV_PCIE_REPLAY_ROLLOVER_COUNTER: u32 = 95;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L6: u32 = 96;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L7: u32 = 97;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L8: u32 = 98;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L9: u32 = 99;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L10: u32 = 100;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L11: u32 = 101;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L6: u32 = 102;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L7: u32 = 103;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L8: u32 = 104;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L9: u32 = 105;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L10: u32 = 106;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L11: u32 = 107;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L6: u32 = 108;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L7: u32 = 109;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L8: u32 = 110;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L9: u32 = 111;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L10: u32 = 112;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L11: u32 = 113;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L6: u32 = 114;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L7: u32 = 115;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L8: u32 = 116;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L9: u32 = 117;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L10: u32 = 118;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L11: u32 = 119;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L6: u32 = 120;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L7: u32 = 121;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L8: u32 = 122;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L9: u32 = 123;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L10: u32 = 124;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L11: u32 = 125;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L6: u32 = 126;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L7: u32 = 127;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L8: u32 = 128;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L9: u32 = 129;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L10: u32 = 130;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L11: u32 = 131;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L6: u32 = 132;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L7: u32 = 133;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L8: u32 = 134;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L9: u32 = 135;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L10: u32 = 136;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L11: u32 = 137;
pub const NVML_FI_DEV_NVLINK_THROUGHPUT_DATA_TX: u32 = 138;
pub const NVML_FI_DEV_NVLINK_THROUGHPUT_DATA_RX: u32 = 139;
pub const NVML_FI_DEV_NVLINK_THROUGHPUT_RAW_TX: u32 = 140;
pub const NVML_FI_DEV_NVLINK_THROUGHPUT_RAW_RX: u32 = 141;
pub const NVML_FI_DEV_REMAPPED_COR: u32 = 142;
pub const NVML_FI_DEV_REMAPPED_UNC: u32 = 143;
pub const NVML_FI_DEV_REMAPPED_PENDING: u32 = 144;
pub const NVML_FI_DEV_REMAPPED_FAILURE: u32 = 145;
pub const NVML_FI_DEV_NVLINK_REMOTE_NVLINK_ID: u32 = 146;
pub const NVML_FI_DEV_NVSWITCH_CONNECTED_LINK_COUNT: u32 = 147;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L0: u32 = 148;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L1: u32 = 149;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L2: u32 = 150;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L3: u32 = 151;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L4: u32 = 152;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L5: u32 = 153;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L6: u32 = 154;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L7: u32 = 155;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L8: u32 = 156;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L9: u32 = 157;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L10: u32 = 158;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L11: u32 = 159;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_TOTAL: u32 = 160;
pub const NVML_FI_DEV_NVLINK_ERROR_DL_REPLAY: u32 = 161;
pub const NVML_FI_DEV_NVLINK_ERROR_DL_RECOVERY: u32 = 162;
pub const NVML_FI_DEV_NVLINK_ERROR_DL_CRC: u32 = 163;
pub const NVML_FI_DEV_NVLINK_GET_SPEED: u32 = 164;
pub const NVML_FI_DEV_NVLINK_GET_STATE: u32 = 165;
pub const NVML_FI_DEV_NVLINK_GET_VERSION: u32 = 166;
pub const NVML_FI_DEV_NVLINK_GET_POWER_STATE: u32 = 167;
pub const NVML_FI_DEV_NVLINK_GET_POWER_THRESHOLD: u32 = 168;
pub const NVML_FI_DEV_PCIE_L0_TO_RECOVERY_COUNTER: u32 = 169;
pub const NVML_FI_DEV_C2C_LINK_COUNT: u32 = 170;
pub const NVML_FI_DEV_C2C_LINK_GET_STATUS: u32 = 171;
pub const NVML_FI_DEV_C2C_LINK_GET_MAX_BW: u32 = 172;
pub const NVML_FI_DEV_PCIE_COUNT_CORRECTABLE_ERRORS: u32 = 173;
pub const NVML_FI_DEV_PCIE_COUNT_NAKS_RECEIVED: u32 = 174;
pub const NVML_FI_DEV_PCIE_COUNT_RECEIVER_ERROR: u32 = 175;
pub const NVML_FI_DEV_PCIE_COUNT_BAD_TLP: u32 = 176;
pub const NVML_FI_DEV_PCIE_COUNT_NAKS_SENT: u32 = 177;
pub const NVML_FI_DEV_PCIE_COUNT_BAD_DLLP: u32 = 178;
pub const NVML_FI_DEV_PCIE_COUNT_NON_FATAL_ERROR: u32 = 179;
pub const NVML_FI_DEV_PCIE_COUNT_FATAL_ERROR: u32 = 180;
pub const NVML_FI_DEV_PCIE_COUNT_UNSUPPORTED_REQ: u32 = 181;
pub const NVML_FI_DEV_PCIE_COUNT_LCRC_ERROR: u32 = 182;
pub const NVML_FI_DEV_PCIE_COUNT_LANE_ERROR: u32 = 183;
pub const NVML_FI_DEV_IS_RESETLESS_MIG_SUPPORTED: u32 = 184;
pub const NVML_FI_DEV_POWER_AVERAGE: u32 = 185;
pub const NVML_FI_DEV_POWER_INSTANT: u32 = 186;
pub const NVML_FI_DEV_POWER_MIN_LIMIT: u32 = 187;
pub const NVML_FI_DEV_POWER_MAX_LIMIT: u32 = 188;
pub const NVML_FI_DEV_POWER_DEFAULT_LIMIT: u32 = 189;
pub const NVML_FI_DEV_POWER_CURRENT_LIMIT: u32 = 190;
pub const NVML_FI_DEV_ENERGY: u32 = 191;
pub const NVML_FI_DEV_POWER_REQUESTED_LIMIT: u32 = 192;
pub const NVML_FI_DEV_TEMPERATURE_SHUTDOWN_TLIMIT: u32 = 193;
pub const NVML_FI_DEV_TEMPERATURE_SLOWDOWN_TLIMIT: u32 = 194;
pub const NVML_FI_DEV_TEMPERATURE_MEM_MAX_TLIMIT: u32 = 195;
pub const NVML_FI_DEV_TEMPERATURE_GPU_MAX_TLIMIT: u32 = 196;
pub const NVML_FI_MAX: u32 = 197;
pub const NVML_NVFBC_SESSION_FLAG_DIFFMAP_ENABLED: u32 = 1;
pub const NVML_NVFBC_SESSION_FLAG_CLASSIFICATIONMAP_ENABLED: u32 = 2;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_NO_WAIT: u32 = 4;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_INFINITE: u32 = 8;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_TIMEOUT: u32 = 16;
pub const NVML_CC_SYSTEM_CPU_CAPS_NONE: u32 = 0;
pub const NVML_CC_SYSTEM_CPU_CAPS_AMD_SEV: u32 = 1;
pub const NVML_CC_SYSTEM_GPUS_CC_NOT_CAPABLE: u32 = 0;
pub const NVML_CC_SYSTEM_GPUS_CC_CAPABLE: u32 = 1;
pub const NVML_CC_SYSTEM_DEVTOOLS_MODE_OFF: u32 = 0;
pub const NVML_CC_SYSTEM_DEVTOOLS_MODE_ON: u32 = 1;
pub const NVML_CC_SYSTEM_ENVIRONMENT_UNAVAILABLE: u32 = 0;
pub const NVML_CC_SYSTEM_ENVIRONMENT_SIM: u32 = 1;
pub const NVML_CC_SYSTEM_ENVIRONMENT_PROD: u32 = 2;
pub const NVML_CC_SYSTEM_FEATURE_DISABLED: u32 = 0;
pub const NVML_CC_SYSTEM_FEATURE_ENABLED: u32 = 1;
pub const NVML_CC_ACCEPTING_CLIENT_REQUESTS_FALSE: u32 = 0;
pub const NVML_CC_ACCEPTING_CLIENT_REQUESTS_TRUE: u32 = 1;
pub const NVML_GPU_CERT_CHAIN_SIZE: u32 = 4096;
pub const NVML_GPU_ATTESTATION_CERT_CHAIN_SIZE: u32 = 5120;
pub const NVML_CC_GPU_CEC_NONCE_SIZE: u32 = 32;
pub const NVML_CC_GPU_ATTESTATION_REPORT_SIZE: u32 = 8192;
pub const NVML_CC_GPU_CEC_ATTESTATION_REPORT_SIZE: u32 = 4096;
pub const NVML_CC_CEC_ATTESTATION_REPORT_NOT_PRESENT: u32 = 0;
pub const NVML_CC_CEC_ATTESTATION_REPORT_PRESENT: u32 = 1;
pub const NVML_GPU_FABRIC_UUID_LEN: u32 = 16;
pub const NVML_GPU_FABRIC_STATE_NOT_SUPPORTED: u32 = 0;
pub const NVML_GPU_FABRIC_STATE_NOT_STARTED: u32 = 1;
pub const NVML_GPU_FABRIC_STATE_IN_PROGRESS: u32 = 2;
pub const NVML_GPU_FABRIC_STATE_COMPLETED: u32 = 3;
pub const NVML_POWER_SCOPE_GPU: u32 = 0;
pub const NVML_POWER_SCOPE_MODULE: u32 = 1;
pub const NVML_INIT_FLAG_NO_GPUS: u32 = 1;
pub const NVML_INIT_FLAG_NO_ATTACH: u32 = 2;
pub const NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE: u32 = 16;
pub const NVML_DEVICE_UUID_BUFFER_SIZE: u32 = 80;
pub const NVML_DEVICE_UUID_V2_BUFFER_SIZE: u32 = 96;
pub const NVML_DEVICE_PART_NUMBER_BUFFER_SIZE: u32 = 80;
pub const NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE: u32 = 80;
pub const NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE: u32 = 80;
pub const NVML_DEVICE_NAME_BUFFER_SIZE: u32 = 64;
pub const NVML_DEVICE_NAME_V2_BUFFER_SIZE: u32 = 96;
pub const NVML_DEVICE_SERIAL_BUFFER_SIZE: u32 = 30;
pub const NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE: u32 = 32;
pub const NVML_AFFINITY_SCOPE_NODE: u32 = 0;
pub const NVML_AFFINITY_SCOPE_SOCKET: u32 = 1;
pub const NVML_DEVICE_MIG_DISABLE: u32 = 0;
pub const NVML_DEVICE_MIG_ENABLE: u32 = 1;
pub const NVML_GPU_INSTANCE_PROFILE_1_SLICE: u32 = 0;
pub const NVML_GPU_INSTANCE_PROFILE_2_SLICE: u32 = 1;
pub const NVML_GPU_INSTANCE_PROFILE_3_SLICE: u32 = 2;
pub const NVML_GPU_INSTANCE_PROFILE_4_SLICE: u32 = 3;
pub const NVML_GPU_INSTANCE_PROFILE_7_SLICE: u32 = 4;
pub const NVML_GPU_INSTANCE_PROFILE_8_SLICE: u32 = 5;
pub const NVML_GPU_INSTANCE_PROFILE_6_SLICE: u32 = 6;
pub const NVML_GPU_INSTANCE_PROFILE_1_SLICE_REV1: u32 = 7;
pub const NVML_GPU_INSTANCE_PROFILE_2_SLICE_REV1: u32 = 8;
pub const NVML_GPU_INSTANCE_PROFILE_1_SLICE_REV2: u32 = 9;
pub const NVML_GPU_INSTANCE_PROFILE_COUNT: u32 = 10;
pub const NVML_COMPUTE_INSTANCE_PROFILE_1_SLICE: u32 = 0;
pub const NVML_COMPUTE_INSTANCE_PROFILE_2_SLICE: u32 = 1;
pub const NVML_COMPUTE_INSTANCE_PROFILE_3_SLICE: u32 = 2;
pub const NVML_COMPUTE_INSTANCE_PROFILE_4_SLICE: u32 = 3;
pub const NVML_COMPUTE_INSTANCE_PROFILE_7_SLICE: u32 = 4;
pub const NVML_COMPUTE_INSTANCE_PROFILE_8_SLICE: u32 = 5;
pub const NVML_COMPUTE_INSTANCE_PROFILE_6_SLICE: u32 = 6;
pub const NVML_COMPUTE_INSTANCE_PROFILE_1_SLICE_REV1: u32 = 7;
pub const NVML_COMPUTE_INSTANCE_PROFILE_COUNT: u32 = 8;
pub const NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_SHARED: u32 = 0;
pub const NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_COUNT: u32 = 1;
pub const NVML_GPM_METRICS_GET_VERSION: u32 = 1;
pub const NVML_GPM_SUPPORT_VERSION: u32 = 1;
pub const NVML_NVLINK_POWER_STATE_HIGH_SPEED: u32 = 0;
pub const NVML_NVLINK_POWER_STATE_LOW: u32 = 1;
pub const NVML_NVLINK_LOW_POWER_THRESHOLD_MIN: u32 = 1;
pub const NVML_NVLINK_LOW_POWER_THRESHOLD_MAX: u32 = 8191;
pub const NVML_NVLINK_LOW_POWER_THRESHOLD_RESET: u32 = 4294967295;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlDevice_st {
    _unused: [u8; 0],
}
pub type nvmlDevice_t = *mut nvmlDevice_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlPciInfo_st {
    pub busIdLegacy: [::std::os::raw::c_char; 16usize],
    pub domain: ::std::os::raw::c_uint,
    pub bus: ::std::os::raw::c_uint,
    pub device: ::std::os::raw::c_uint,
    pub pciDeviceId: ::std::os::raw::c_uint,
    pub pciSubSystemId: ::std::os::raw::c_uint,
    pub busId: [::std::os::raw::c_char; 32usize],
}
pub type nvmlPciInfo_t = nvmlPciInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlEccErrorCounts_st {
    pub l1Cache: ::std::os::raw::c_ulonglong,
    pub l2Cache: ::std::os::raw::c_ulonglong,
    pub deviceMemory: ::std::os::raw::c_ulonglong,
    pub registerFile: ::std::os::raw::c_ulonglong,
}
pub type nvmlEccErrorCounts_t = nvmlEccErrorCounts_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUtilization_st {
    pub gpu: ::std::os::raw::c_uint,
    pub memory: ::std::os::raw::c_uint,
}
pub type nvmlUtilization_t = nvmlUtilization_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlMemory_st {
    pub total: ::std::os::raw::c_ulonglong,
    pub free: ::std::os::raw::c_ulonglong,
    pub used: ::std::os::raw::c_ulonglong,
}
pub type nvmlMemory_t = nvmlMemory_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlMemory_v2_st {
    pub version: ::std::os::raw::c_uint,
    pub total: ::std::os::raw::c_ulonglong,
    pub reserved: ::std::os::raw::c_ulonglong,
    pub free: ::std::os::raw::c_ulonglong,
    pub used: ::std::os::raw::c_ulonglong,
}
pub type nvmlMemory_v2_t = nvmlMemory_v2_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBAR1Memory_st {
    pub bar1Total: ::std::os::raw::c_ulonglong,
    pub bar1Free: ::std::os::raw::c_ulonglong,
    pub bar1Used: ::std::os::raw::c_ulonglong,
}
pub type nvmlBAR1Memory_t = nvmlBAR1Memory_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlProcessInfo_v1_st {
    pub pid: ::std::os::raw::c_uint,
    pub usedGpuMemory: ::std::os::raw::c_ulonglong,
}
pub type nvmlProcessInfo_v1_t = nvmlProcessInfo_v1_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlProcessInfo_v2_st {
    pub pid: ::std::os::raw::c_uint,
    pub usedGpuMemory: ::std::os::raw::c_ulonglong,
    pub gpuInstanceId: ::std::os::raw::c_uint,
    pub computeInstanceId: ::std::os::raw::c_uint,
}
pub type nvmlProcessInfo_v2_t = nvmlProcessInfo_v2_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlProcessInfo_st {
    pub pid: ::std::os::raw::c_uint,
    pub usedGpuMemory: ::std::os::raw::c_ulonglong,
    pub gpuInstanceId: ::std::os::raw::c_uint,
    pub computeInstanceId: ::std::os::raw::c_uint,
    pub usedGpuCcProtectedMemory: ::std::os::raw::c_ulonglong,
}
pub type nvmlProcessInfo_t = nvmlProcessInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlDeviceAttributes_st {
    pub multiprocessorCount: ::std::os::raw::c_uint,
    pub sharedCopyEngineCount: ::std::os::raw::c_uint,
    pub sharedDecoderCount: ::std::os::raw::c_uint,
    pub sharedEncoderCount: ::std::os::raw::c_uint,
    pub sharedJpegCount: ::std::os::raw::c_uint,
    pub sharedOfaCount: ::std::os::raw::c_uint,
    pub gpuInstanceSliceCount: ::std::os::raw::c_uint,
    pub computeInstanceSliceCount: ::std::os::raw::c_uint,
    pub memorySizeMB: ::std::os::raw::c_ulonglong,
}
pub type nvmlDeviceAttributes_t = nvmlDeviceAttributes_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlRowRemapperHistogramValues_st {
    pub max: ::std::os::raw::c_uint,
    pub high: ::std::os::raw::c_uint,
    pub partial: ::std::os::raw::c_uint,
    pub low: ::std::os::raw::c_uint,
    pub none: ::std::os::raw::c_uint,
}
pub type nvmlRowRemapperHistogramValues_t = nvmlRowRemapperHistogramValues_st;
impl nvmlBridgeChipType_enum {
    pub const NVML_BRIDGE_CHIP_PLX: nvmlBridgeChipType_enum = nvmlBridgeChipType_enum(0);
}
impl nvmlBridgeChipType_enum {
    pub const NVML_BRIDGE_CHIP_BRO4: nvmlBridgeChipType_enum = nvmlBridgeChipType_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlBridgeChipType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlBridgeChipType_enum as nvmlBridgeChipType_t;
impl nvmlNvLinkUtilizationCountUnits_enum {
    pub const NVML_NVLINK_COUNTER_UNIT_CYCLES: nvmlNvLinkUtilizationCountUnits_enum =
        nvmlNvLinkUtilizationCountUnits_enum(0);
}
impl nvmlNvLinkUtilizationCountUnits_enum {
    pub const NVML_NVLINK_COUNTER_UNIT_PACKETS: nvmlNvLinkUtilizationCountUnits_enum =
        nvmlNvLinkUtilizationCountUnits_enum(1);
}
impl nvmlNvLinkUtilizationCountUnits_enum {
    pub const NVML_NVLINK_COUNTER_UNIT_BYTES: nvmlNvLinkUtilizationCountUnits_enum =
        nvmlNvLinkUtilizationCountUnits_enum(2);
}
impl nvmlNvLinkUtilizationCountUnits_enum {
    pub const NVML_NVLINK_COUNTER_UNIT_RESERVED: nvmlNvLinkUtilizationCountUnits_enum =
        nvmlNvLinkUtilizationCountUnits_enum(3);
}
impl nvmlNvLinkUtilizationCountUnits_enum {
    pub const NVML_NVLINK_COUNTER_UNIT_COUNT: nvmlNvLinkUtilizationCountUnits_enum =
        nvmlNvLinkUtilizationCountUnits_enum(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlNvLinkUtilizationCountUnits_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlNvLinkUtilizationCountUnits_enum as nvmlNvLinkUtilizationCountUnits_t;
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_NOP: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(1);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_READ: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(2);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_WRITE: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(4);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_RATOM: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(8);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_NRATOM: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(16);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_FLUSH: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(32);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(64);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(128);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_ALL: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(255);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlNvLinkUtilizationCountPktTypes_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlNvLinkUtilizationCountPktTypes_enum as nvmlNvLinkUtilizationCountPktTypes_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlNvLinkUtilizationControl_st {
    pub units: nvmlNvLinkUtilizationCountUnits_t,
    pub pktfilter: nvmlNvLinkUtilizationCountPktTypes_t,
}
pub type nvmlNvLinkUtilizationControl_t = nvmlNvLinkUtilizationControl_st;
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_P2P_SUPPORTED: nvmlNvLinkCapability_enum =
        nvmlNvLinkCapability_enum(0);
}
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_SYSMEM_ACCESS: nvmlNvLinkCapability_enum =
        nvmlNvLinkCapability_enum(1);
}
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_P2P_ATOMICS: nvmlNvLinkCapability_enum = nvmlNvLinkCapability_enum(2);
}
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_SYSMEM_ATOMICS: nvmlNvLinkCapability_enum =
        nvmlNvLinkCapability_enum(3);
}
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_SLI_BRIDGE: nvmlNvLinkCapability_enum = nvmlNvLinkCapability_enum(4);
}
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_VALID: nvmlNvLinkCapability_enum = nvmlNvLinkCapability_enum(5);
}
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_COUNT: nvmlNvLinkCapability_enum = nvmlNvLinkCapability_enum(6);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlNvLinkCapability_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlNvLinkCapability_enum as nvmlNvLinkCapability_t;
impl nvmlNvLinkErrorCounter_enum {
    pub const NVML_NVLINK_ERROR_DL_REPLAY: nvmlNvLinkErrorCounter_enum =
        nvmlNvLinkErrorCounter_enum(0);
}
impl nvmlNvLinkErrorCounter_enum {
    pub const NVML_NVLINK_ERROR_DL_RECOVERY: nvmlNvLinkErrorCounter_enum =
        nvmlNvLinkErrorCounter_enum(1);
}
impl nvmlNvLinkErrorCounter_enum {
    pub const NVML_NVLINK_ERROR_DL_CRC_FLIT: nvmlNvLinkErrorCounter_enum =
        nvmlNvLinkErrorCounter_enum(2);
}
impl nvmlNvLinkErrorCounter_enum {
    pub const NVML_NVLINK_ERROR_DL_CRC_DATA: nvmlNvLinkErrorCounter_enum =
        nvmlNvLinkErrorCounter_enum(3);
}
impl nvmlNvLinkErrorCounter_enum {
    pub const NVML_NVLINK_ERROR_DL_ECC_DATA: nvmlNvLinkErrorCounter_enum =
        nvmlNvLinkErrorCounter_enum(4);
}
impl nvmlNvLinkErrorCounter_enum {
    pub const NVML_NVLINK_ERROR_COUNT: nvmlNvLinkErrorCounter_enum = nvmlNvLinkErrorCounter_enum(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlNvLinkErrorCounter_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlNvLinkErrorCounter_enum as nvmlNvLinkErrorCounter_t;
impl nvmlIntNvLinkDeviceType_enum {
    pub const NVML_NVLINK_DEVICE_TYPE_GPU: nvmlIntNvLinkDeviceType_enum =
        nvmlIntNvLinkDeviceType_enum(0);
}
impl nvmlIntNvLinkDeviceType_enum {
    pub const NVML_NVLINK_DEVICE_TYPE_IBMNPU: nvmlIntNvLinkDeviceType_enum =
        nvmlIntNvLinkDeviceType_enum(1);
}
impl nvmlIntNvLinkDeviceType_enum {
    pub const NVML_NVLINK_DEVICE_TYPE_SWITCH: nvmlIntNvLinkDeviceType_enum =
        nvmlIntNvLinkDeviceType_enum(2);
}
impl nvmlIntNvLinkDeviceType_enum {
    pub const NVML_NVLINK_DEVICE_TYPE_UNKNOWN: nvmlIntNvLinkDeviceType_enum =
        nvmlIntNvLinkDeviceType_enum(255);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlIntNvLinkDeviceType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlIntNvLinkDeviceType_enum as nvmlIntNvLinkDeviceType_t;
impl nvmlGpuLevel_enum {
    pub const NVML_TOPOLOGY_INTERNAL: nvmlGpuLevel_enum = nvmlGpuLevel_enum(0);
}
impl nvmlGpuLevel_enum {
    pub const NVML_TOPOLOGY_SINGLE: nvmlGpuLevel_enum = nvmlGpuLevel_enum(10);
}
impl nvmlGpuLevel_enum {
    pub const NVML_TOPOLOGY_MULTIPLE: nvmlGpuLevel_enum = nvmlGpuLevel_enum(20);
}
impl nvmlGpuLevel_enum {
    pub const NVML_TOPOLOGY_HOSTBRIDGE: nvmlGpuLevel_enum = nvmlGpuLevel_enum(30);
}
impl nvmlGpuLevel_enum {
    pub const NVML_TOPOLOGY_NODE: nvmlGpuLevel_enum = nvmlGpuLevel_enum(40);
}
impl nvmlGpuLevel_enum {
    pub const NVML_TOPOLOGY_SYSTEM: nvmlGpuLevel_enum = nvmlGpuLevel_enum(50);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlGpuLevel_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlGpuLevel_enum as nvmlGpuTopologyLevel_t;
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_OK: nvmlGpuP2PStatus_enum = nvmlGpuP2PStatus_enum(0);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED: nvmlGpuP2PStatus_enum =
        nvmlGpuP2PStatus_enum(1);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_CHIPSET_NOT_SUPPORTED: nvmlGpuP2PStatus_enum =
        nvmlGpuP2PStatus_enum(1);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_GPU_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = nvmlGpuP2PStatus_enum(2);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED: nvmlGpuP2PStatus_enum =
        nvmlGpuP2PStatus_enum(3);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_DISABLED_BY_REGKEY: nvmlGpuP2PStatus_enum = nvmlGpuP2PStatus_enum(4);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = nvmlGpuP2PStatus_enum(5);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_UNKNOWN: nvmlGpuP2PStatus_enum = nvmlGpuP2PStatus_enum(6);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlGpuP2PStatus_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlGpuP2PStatus_enum as nvmlGpuP2PStatus_t;
impl nvmlGpuP2PCapsIndex_enum {
    pub const NVML_P2P_CAPS_INDEX_READ: nvmlGpuP2PCapsIndex_enum = nvmlGpuP2PCapsIndex_enum(0);
}
impl nvmlGpuP2PCapsIndex_enum {
    pub const NVML_P2P_CAPS_INDEX_WRITE: nvmlGpuP2PCapsIndex_enum = nvmlGpuP2PCapsIndex_enum(1);
}
impl nvmlGpuP2PCapsIndex_enum {
    pub const NVML_P2P_CAPS_INDEX_NVLINK: nvmlGpuP2PCapsIndex_enum = nvmlGpuP2PCapsIndex_enum(2);
}
impl nvmlGpuP2PCapsIndex_enum {
    pub const NVML_P2P_CAPS_INDEX_ATOMICS: nvmlGpuP2PCapsIndex_enum = nvmlGpuP2PCapsIndex_enum(3);
}
impl nvmlGpuP2PCapsIndex_enum {
    pub const NVML_P2P_CAPS_INDEX_PROP: nvmlGpuP2PCapsIndex_enum = nvmlGpuP2PCapsIndex_enum(4);
}
impl nvmlGpuP2PCapsIndex_enum {
    pub const NVML_P2P_CAPS_INDEX_UNKNOWN: nvmlGpuP2PCapsIndex_enum = nvmlGpuP2PCapsIndex_enum(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlGpuP2PCapsIndex_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlGpuP2PCapsIndex_enum as nvmlGpuP2PCapsIndex_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBridgeChipInfo_st {
    pub type_: nvmlBridgeChipType_t,
    pub fwVersion: ::std::os::raw::c_uint,
}
pub type nvmlBridgeChipInfo_t = nvmlBridgeChipInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBridgeChipHierarchy_st {
    pub bridgeCount: ::std::os::raw::c_uchar,
    pub bridgeChipInfo: [nvmlBridgeChipInfo_t; 128usize],
}
pub type nvmlBridgeChipHierarchy_t = nvmlBridgeChipHierarchy_st;
impl nvmlSamplingType_enum {
    pub const NVML_TOTAL_POWER_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(0);
}
impl nvmlSamplingType_enum {
    pub const NVML_GPU_UTILIZATION_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(1);
}
impl nvmlSamplingType_enum {
    pub const NVML_MEMORY_UTILIZATION_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(2);
}
impl nvmlSamplingType_enum {
    pub const NVML_ENC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(3);
}
impl nvmlSamplingType_enum {
    pub const NVML_DEC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(4);
}
impl nvmlSamplingType_enum {
    pub const NVML_PROCESSOR_CLK_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(5);
}
impl nvmlSamplingType_enum {
    pub const NVML_MEMORY_CLK_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(6);
}
impl nvmlSamplingType_enum {
    pub const NVML_MODULE_POWER_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(7);
}
impl nvmlSamplingType_enum {
    pub const NVML_SAMPLINGTYPE_COUNT: nvmlSamplingType_enum = nvmlSamplingType_enum(8);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlSamplingType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlSamplingType_enum as nvmlSamplingType_t;
impl nvmlPcieUtilCounter_enum {
    pub const NVML_PCIE_UTIL_TX_BYTES: nvmlPcieUtilCounter_enum = nvmlPcieUtilCounter_enum(0);
}
impl nvmlPcieUtilCounter_enum {
    pub const NVML_PCIE_UTIL_RX_BYTES: nvmlPcieUtilCounter_enum = nvmlPcieUtilCounter_enum(1);
}
impl nvmlPcieUtilCounter_enum {
    pub const NVML_PCIE_UTIL_COUNT: nvmlPcieUtilCounter_enum = nvmlPcieUtilCounter_enum(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlPcieUtilCounter_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlPcieUtilCounter_enum as nvmlPcieUtilCounter_t;
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_DOUBLE: nvmlValueType_enum = nvmlValueType_enum(0);
}
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_UNSIGNED_INT: nvmlValueType_enum = nvmlValueType_enum(1);
}
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_UNSIGNED_LONG: nvmlValueType_enum = nvmlValueType_enum(2);
}
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_UNSIGNED_LONG_LONG: nvmlValueType_enum = nvmlValueType_enum(3);
}
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_SIGNED_LONG_LONG: nvmlValueType_enum = nvmlValueType_enum(4);
}
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_SIGNED_INT: nvmlValueType_enum = nvmlValueType_enum(5);
}
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_COUNT: nvmlValueType_enum = nvmlValueType_enum(6);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlValueType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlValueType_enum as nvmlValueType_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvmlValue_st {
    pub dVal: f64,
    pub siVal: ::std::os::raw::c_int,
    pub uiVal: ::std::os::raw::c_uint,
    pub ulVal: ::std::os::raw::c_ulong,
    pub ullVal: ::std::os::raw::c_ulonglong,
    pub sllVal: ::std::os::raw::c_longlong,
}
pub type nvmlValue_t = nvmlValue_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlSample_st {
    pub timeStamp: ::std::os::raw::c_ulonglong,
    pub sampleValue: nvmlValue_t,
}
pub type nvmlSample_t = nvmlSample_st;
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_POWER: nvmlPerfPolicyType_enum = nvmlPerfPolicyType_enum(0);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_THERMAL: nvmlPerfPolicyType_enum = nvmlPerfPolicyType_enum(1);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_SYNC_BOOST: nvmlPerfPolicyType_enum = nvmlPerfPolicyType_enum(2);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_BOARD_LIMIT: nvmlPerfPolicyType_enum = nvmlPerfPolicyType_enum(3);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_LOW_UTILIZATION: nvmlPerfPolicyType_enum =
        nvmlPerfPolicyType_enum(4);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_RELIABILITY: nvmlPerfPolicyType_enum = nvmlPerfPolicyType_enum(5);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_TOTAL_APP_CLOCKS: nvmlPerfPolicyType_enum =
        nvmlPerfPolicyType_enum(10);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_TOTAL_BASE_CLOCKS: nvmlPerfPolicyType_enum =
        nvmlPerfPolicyType_enum(11);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_COUNT: nvmlPerfPolicyType_enum = nvmlPerfPolicyType_enum(12);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlPerfPolicyType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlPerfPolicyType_enum as nvmlPerfPolicyType_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlViolationTime_st {
    pub referenceTime: ::std::os::raw::c_ulonglong,
    pub violationTime: ::std::os::raw::c_ulonglong,
}
pub type nvmlViolationTime_t = nvmlViolationTime_st;
impl nvmlThermalTarget_t {
    pub const NVML_THERMAL_TARGET_NONE: nvmlThermalTarget_t = nvmlThermalTarget_t(0);
}
impl nvmlThermalTarget_t {
    pub const NVML_THERMAL_TARGET_GPU: nvmlThermalTarget_t = nvmlThermalTarget_t(1);
}
impl nvmlThermalTarget_t {
    pub const NVML_THERMAL_TARGET_MEMORY: nvmlThermalTarget_t = nvmlThermalTarget_t(2);
}
impl nvmlThermalTarget_t {
    pub const NVML_THERMAL_TARGET_POWER_SUPPLY: nvmlThermalTarget_t = nvmlThermalTarget_t(4);
}
impl nvmlThermalTarget_t {
    pub const NVML_THERMAL_TARGET_BOARD: nvmlThermalTarget_t = nvmlThermalTarget_t(8);
}
impl nvmlThermalTarget_t {
    pub const NVML_THERMAL_TARGET_VCD_BOARD: nvmlThermalTarget_t = nvmlThermalTarget_t(9);
}
impl nvmlThermalTarget_t {
    pub const NVML_THERMAL_TARGET_VCD_INLET: nvmlThermalTarget_t = nvmlThermalTarget_t(10);
}
impl nvmlThermalTarget_t {
    pub const NVML_THERMAL_TARGET_VCD_OUTLET: nvmlThermalTarget_t = nvmlThermalTarget_t(11);
}
impl nvmlThermalTarget_t {
    pub const NVML_THERMAL_TARGET_ALL: nvmlThermalTarget_t = nvmlThermalTarget_t(15);
}
impl nvmlThermalTarget_t {
    pub const NVML_THERMAL_TARGET_UNKNOWN: nvmlThermalTarget_t = nvmlThermalTarget_t(-1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlThermalTarget_t(pub ::std::os::raw::c_int);
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_NONE: nvmlThermalController_t = nvmlThermalController_t(0);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_GPU_INTERNAL: nvmlThermalController_t =
        nvmlThermalController_t(1);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_ADM1032: nvmlThermalController_t = nvmlThermalController_t(2);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_ADT7461: nvmlThermalController_t = nvmlThermalController_t(3);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_MAX6649: nvmlThermalController_t = nvmlThermalController_t(4);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_MAX1617: nvmlThermalController_t = nvmlThermalController_t(5);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_LM99: nvmlThermalController_t = nvmlThermalController_t(6);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_LM89: nvmlThermalController_t = nvmlThermalController_t(7);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_LM64: nvmlThermalController_t = nvmlThermalController_t(8);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_G781: nvmlThermalController_t = nvmlThermalController_t(9);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_ADT7473: nvmlThermalController_t =
        nvmlThermalController_t(10);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_SBMAX6649: nvmlThermalController_t =
        nvmlThermalController_t(11);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_VBIOSEVT: nvmlThermalController_t =
        nvmlThermalController_t(12);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_OS: nvmlThermalController_t = nvmlThermalController_t(13);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_NVSYSCON_CANOAS: nvmlThermalController_t =
        nvmlThermalController_t(14);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_NVSYSCON_E551: nvmlThermalController_t =
        nvmlThermalController_t(15);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_MAX6649R: nvmlThermalController_t =
        nvmlThermalController_t(16);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_ADT7473S: nvmlThermalController_t =
        nvmlThermalController_t(17);
}
impl nvmlThermalController_t {
    pub const NVML_THERMAL_CONTROLLER_UNKNOWN: nvmlThermalController_t =
        nvmlThermalController_t(-1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlThermalController_t(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuThermalSettings_t {
    pub count: ::std::os::raw::c_uint,
    pub sensor: [nvmlGpuThermalSettings_t__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuThermalSettings_t__bindgen_ty_1 {
    pub controller: nvmlThermalController_t,
    pub defaultMinTemp: ::std::os::raw::c_int,
    pub defaultMaxTemp: ::std::os::raw::c_int,
    pub currentTemp: ::std::os::raw::c_int,
    pub target: nvmlThermalTarget_t,
}
impl nvmlEnableState_enum {
    pub const NVML_FEATURE_DISABLED: nvmlEnableState_enum = nvmlEnableState_enum(0);
}
impl nvmlEnableState_enum {
    pub const NVML_FEATURE_ENABLED: nvmlEnableState_enum = nvmlEnableState_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlEnableState_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlEnableState_enum as nvmlEnableState_t;
impl nvmlBrandType_enum {
    pub const NVML_BRAND_UNKNOWN: nvmlBrandType_enum = nvmlBrandType_enum(0);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_QUADRO: nvmlBrandType_enum = nvmlBrandType_enum(1);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_TESLA: nvmlBrandType_enum = nvmlBrandType_enum(2);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_NVS: nvmlBrandType_enum = nvmlBrandType_enum(3);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_GRID: nvmlBrandType_enum = nvmlBrandType_enum(4);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_GEFORCE: nvmlBrandType_enum = nvmlBrandType_enum(5);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_TITAN: nvmlBrandType_enum = nvmlBrandType_enum(6);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_NVIDIA_VAPPS: nvmlBrandType_enum = nvmlBrandType_enum(7);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_NVIDIA_VPC: nvmlBrandType_enum = nvmlBrandType_enum(8);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_NVIDIA_VCS: nvmlBrandType_enum = nvmlBrandType_enum(9);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_NVIDIA_VWS: nvmlBrandType_enum = nvmlBrandType_enum(10);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_NVIDIA_CLOUD_GAMING: nvmlBrandType_enum = nvmlBrandType_enum(11);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_NVIDIA_VGAMING: nvmlBrandType_enum = nvmlBrandType_enum(11);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_QUADRO_RTX: nvmlBrandType_enum = nvmlBrandType_enum(12);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_NVIDIA_RTX: nvmlBrandType_enum = nvmlBrandType_enum(13);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_NVIDIA: nvmlBrandType_enum = nvmlBrandType_enum(14);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_GEFORCE_RTX: nvmlBrandType_enum = nvmlBrandType_enum(15);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_TITAN_RTX: nvmlBrandType_enum = nvmlBrandType_enum(16);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_COUNT: nvmlBrandType_enum = nvmlBrandType_enum(17);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlBrandType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlBrandType_enum as nvmlBrandType_t;
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_SHUTDOWN: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(0);
}
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_SLOWDOWN: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(1);
}
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_MEM_MAX: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(2);
}
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_GPU_MAX: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(3);
}
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_ACOUSTIC_MIN: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(4);
}
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_ACOUSTIC_CURR: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(5);
}
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_ACOUSTIC_MAX: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(6);
}
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_COUNT: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlTemperatureThresholds_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlTemperatureThresholds_enum as nvmlTemperatureThresholds_t;
impl nvmlTemperatureSensors_enum {
    pub const NVML_TEMPERATURE_GPU: nvmlTemperatureSensors_enum = nvmlTemperatureSensors_enum(0);
}
impl nvmlTemperatureSensors_enum {
    pub const NVML_TEMPERATURE_COUNT: nvmlTemperatureSensors_enum = nvmlTemperatureSensors_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlTemperatureSensors_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlTemperatureSensors_enum as nvmlTemperatureSensors_t;
impl nvmlComputeMode_enum {
    pub const NVML_COMPUTEMODE_DEFAULT: nvmlComputeMode_enum = nvmlComputeMode_enum(0);
}
impl nvmlComputeMode_enum {
    pub const NVML_COMPUTEMODE_EXCLUSIVE_THREAD: nvmlComputeMode_enum = nvmlComputeMode_enum(1);
}
impl nvmlComputeMode_enum {
    pub const NVML_COMPUTEMODE_PROHIBITED: nvmlComputeMode_enum = nvmlComputeMode_enum(2);
}
impl nvmlComputeMode_enum {
    pub const NVML_COMPUTEMODE_EXCLUSIVE_PROCESS: nvmlComputeMode_enum = nvmlComputeMode_enum(3);
}
impl nvmlComputeMode_enum {
    pub const NVML_COMPUTEMODE_COUNT: nvmlComputeMode_enum = nvmlComputeMode_enum(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlComputeMode_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlComputeMode_enum as nvmlComputeMode_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlClkMonFaultInfo_struct {
    pub clkApiDomain: ::std::os::raw::c_uint,
    pub clkDomainFaultMask: ::std::os::raw::c_uint,
}
pub type nvmlClkMonFaultInfo_t = nvmlClkMonFaultInfo_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlClkMonStatus_status {
    pub bGlobalStatus: ::std::os::raw::c_uint,
    pub clkMonListSize: ::std::os::raw::c_uint,
    pub clkMonList: [nvmlClkMonFaultInfo_t; 32usize],
}
pub type nvmlClkMonStatus_t = nvmlClkMonStatus_status;
impl nvmlMemoryErrorType_enum {
    pub const NVML_MEMORY_ERROR_TYPE_CORRECTED: nvmlMemoryErrorType_enum =
        nvmlMemoryErrorType_enum(0);
}
impl nvmlMemoryErrorType_enum {
    pub const NVML_MEMORY_ERROR_TYPE_UNCORRECTED: nvmlMemoryErrorType_enum =
        nvmlMemoryErrorType_enum(1);
}
impl nvmlMemoryErrorType_enum {
    pub const NVML_MEMORY_ERROR_TYPE_COUNT: nvmlMemoryErrorType_enum = nvmlMemoryErrorType_enum(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlMemoryErrorType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlMemoryErrorType_enum as nvmlMemoryErrorType_t;
impl nvmlEccCounterType_enum {
    pub const NVML_VOLATILE_ECC: nvmlEccCounterType_enum = nvmlEccCounterType_enum(0);
}
impl nvmlEccCounterType_enum {
    pub const NVML_AGGREGATE_ECC: nvmlEccCounterType_enum = nvmlEccCounterType_enum(1);
}
impl nvmlEccCounterType_enum {
    pub const NVML_ECC_COUNTER_TYPE_COUNT: nvmlEccCounterType_enum = nvmlEccCounterType_enum(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlEccCounterType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlEccCounterType_enum as nvmlEccCounterType_t;
impl nvmlClockType_enum {
    pub const NVML_CLOCK_GRAPHICS: nvmlClockType_enum = nvmlClockType_enum(0);
}
impl nvmlClockType_enum {
    pub const NVML_CLOCK_SM: nvmlClockType_enum = nvmlClockType_enum(1);
}
impl nvmlClockType_enum {
    pub const NVML_CLOCK_MEM: nvmlClockType_enum = nvmlClockType_enum(2);
}
impl nvmlClockType_enum {
    pub const NVML_CLOCK_VIDEO: nvmlClockType_enum = nvmlClockType_enum(3);
}
impl nvmlClockType_enum {
    pub const NVML_CLOCK_COUNT: nvmlClockType_enum = nvmlClockType_enum(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlClockType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlClockType_enum as nvmlClockType_t;
impl nvmlClockId_enum {
    pub const NVML_CLOCK_ID_CURRENT: nvmlClockId_enum = nvmlClockId_enum(0);
}
impl nvmlClockId_enum {
    pub const NVML_CLOCK_ID_APP_CLOCK_TARGET: nvmlClockId_enum = nvmlClockId_enum(1);
}
impl nvmlClockId_enum {
    pub const NVML_CLOCK_ID_APP_CLOCK_DEFAULT: nvmlClockId_enum = nvmlClockId_enum(2);
}
impl nvmlClockId_enum {
    pub const NVML_CLOCK_ID_CUSTOMER_BOOST_MAX: nvmlClockId_enum = nvmlClockId_enum(3);
}
impl nvmlClockId_enum {
    pub const NVML_CLOCK_ID_COUNT: nvmlClockId_enum = nvmlClockId_enum(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlClockId_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlClockId_enum as nvmlClockId_t;
impl nvmlDriverModel_enum {
    pub const NVML_DRIVER_WDDM: nvmlDriverModel_enum = nvmlDriverModel_enum(0);
}
impl nvmlDriverModel_enum {
    pub const NVML_DRIVER_WDM: nvmlDriverModel_enum = nvmlDriverModel_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlDriverModel_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlDriverModel_enum as nvmlDriverModel_t;
impl nvmlPStates_enum {
    pub const NVML_PSTATE_0: nvmlPStates_enum = nvmlPStates_enum(0);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_1: nvmlPStates_enum = nvmlPStates_enum(1);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_2: nvmlPStates_enum = nvmlPStates_enum(2);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_3: nvmlPStates_enum = nvmlPStates_enum(3);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_4: nvmlPStates_enum = nvmlPStates_enum(4);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_5: nvmlPStates_enum = nvmlPStates_enum(5);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_6: nvmlPStates_enum = nvmlPStates_enum(6);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_7: nvmlPStates_enum = nvmlPStates_enum(7);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_8: nvmlPStates_enum = nvmlPStates_enum(8);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_9: nvmlPStates_enum = nvmlPStates_enum(9);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_10: nvmlPStates_enum = nvmlPStates_enum(10);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_11: nvmlPStates_enum = nvmlPStates_enum(11);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_12: nvmlPStates_enum = nvmlPStates_enum(12);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_13: nvmlPStates_enum = nvmlPStates_enum(13);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_14: nvmlPStates_enum = nvmlPStates_enum(14);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_15: nvmlPStates_enum = nvmlPStates_enum(15);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_UNKNOWN: nvmlPStates_enum = nvmlPStates_enum(32);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlPStates_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlPStates_enum as nvmlPstates_t;
impl nvmlGom_enum {
    pub const NVML_GOM_ALL_ON: nvmlGom_enum = nvmlGom_enum(0);
}
impl nvmlGom_enum {
    pub const NVML_GOM_COMPUTE: nvmlGom_enum = nvmlGom_enum(1);
}
impl nvmlGom_enum {
    pub const NVML_GOM_LOW_DP: nvmlGom_enum = nvmlGom_enum(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlGom_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlGom_enum as nvmlGpuOperationMode_t;
impl nvmlInforomObject_enum {
    pub const NVML_INFOROM_OEM: nvmlInforomObject_enum = nvmlInforomObject_enum(0);
}
impl nvmlInforomObject_enum {
    pub const NVML_INFOROM_ECC: nvmlInforomObject_enum = nvmlInforomObject_enum(1);
}
impl nvmlInforomObject_enum {
    pub const NVML_INFOROM_POWER: nvmlInforomObject_enum = nvmlInforomObject_enum(2);
}
impl nvmlInforomObject_enum {
    pub const NVML_INFOROM_COUNT: nvmlInforomObject_enum = nvmlInforomObject_enum(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlInforomObject_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlInforomObject_enum as nvmlInforomObject_t;
impl nvmlReturn_enum {
    pub const NVML_SUCCESS: nvmlReturn_enum = nvmlReturn_enum(0);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_UNINITIALIZED: nvmlReturn_enum = nvmlReturn_enum(1);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_INVALID_ARGUMENT: nvmlReturn_enum = nvmlReturn_enum(2);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_NOT_SUPPORTED: nvmlReturn_enum = nvmlReturn_enum(3);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_NO_PERMISSION: nvmlReturn_enum = nvmlReturn_enum(4);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_ALREADY_INITIALIZED: nvmlReturn_enum = nvmlReturn_enum(5);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_NOT_FOUND: nvmlReturn_enum = nvmlReturn_enum(6);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_INSUFFICIENT_SIZE: nvmlReturn_enum = nvmlReturn_enum(7);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_INSUFFICIENT_POWER: nvmlReturn_enum = nvmlReturn_enum(8);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_DRIVER_NOT_LOADED: nvmlReturn_enum = nvmlReturn_enum(9);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_TIMEOUT: nvmlReturn_enum = nvmlReturn_enum(10);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_IRQ_ISSUE: nvmlReturn_enum = nvmlReturn_enum(11);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_LIBRARY_NOT_FOUND: nvmlReturn_enum = nvmlReturn_enum(12);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_FUNCTION_NOT_FOUND: nvmlReturn_enum = nvmlReturn_enum(13);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_CORRUPTED_INFOROM: nvmlReturn_enum = nvmlReturn_enum(14);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_GPU_IS_LOST: nvmlReturn_enum = nvmlReturn_enum(15);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_RESET_REQUIRED: nvmlReturn_enum = nvmlReturn_enum(16);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_OPERATING_SYSTEM: nvmlReturn_enum = nvmlReturn_enum(17);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_LIB_RM_VERSION_MISMATCH: nvmlReturn_enum = nvmlReturn_enum(18);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_IN_USE: nvmlReturn_enum = nvmlReturn_enum(19);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_MEMORY: nvmlReturn_enum = nvmlReturn_enum(20);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_NO_DATA: nvmlReturn_enum = nvmlReturn_enum(21);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_VGPU_ECC_NOT_SUPPORTED: nvmlReturn_enum = nvmlReturn_enum(22);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_INSUFFICIENT_RESOURCES: nvmlReturn_enum = nvmlReturn_enum(23);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_FREQ_NOT_SUPPORTED: nvmlReturn_enum = nvmlReturn_enum(24);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_ARGUMENT_VERSION_MISMATCH: nvmlReturn_enum = nvmlReturn_enum(25);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_DEPRECATED: nvmlReturn_enum = nvmlReturn_enum(26);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_NOT_READY: nvmlReturn_enum = nvmlReturn_enum(27);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_UNKNOWN: nvmlReturn_enum = nvmlReturn_enum(999);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlReturn_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlReturn_enum as nvmlReturn_t;
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_L1_CACHE: nvmlMemoryLocation_enum = nvmlMemoryLocation_enum(0);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_L2_CACHE: nvmlMemoryLocation_enum = nvmlMemoryLocation_enum(1);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_DRAM: nvmlMemoryLocation_enum = nvmlMemoryLocation_enum(2);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_DEVICE_MEMORY: nvmlMemoryLocation_enum =
        nvmlMemoryLocation_enum(2);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_REGISTER_FILE: nvmlMemoryLocation_enum =
        nvmlMemoryLocation_enum(3);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_TEXTURE_MEMORY: nvmlMemoryLocation_enum =
        nvmlMemoryLocation_enum(4);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_TEXTURE_SHM: nvmlMemoryLocation_enum =
        nvmlMemoryLocation_enum(5);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_CBU: nvmlMemoryLocation_enum = nvmlMemoryLocation_enum(6);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_SRAM: nvmlMemoryLocation_enum = nvmlMemoryLocation_enum(7);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_COUNT: nvmlMemoryLocation_enum = nvmlMemoryLocation_enum(8);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlMemoryLocation_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlMemoryLocation_enum as nvmlMemoryLocation_t;
impl nvmlPageRetirementCause_enum {
    pub const NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS:
        nvmlPageRetirementCause_enum = nvmlPageRetirementCause_enum(0);
}
impl nvmlPageRetirementCause_enum {
    pub const NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR: nvmlPageRetirementCause_enum =
        nvmlPageRetirementCause_enum(1);
}
impl nvmlPageRetirementCause_enum {
    pub const NVML_PAGE_RETIREMENT_CAUSE_COUNT: nvmlPageRetirementCause_enum =
        nvmlPageRetirementCause_enum(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlPageRetirementCause_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlPageRetirementCause_enum as nvmlPageRetirementCause_t;
impl nvmlRestrictedAPI_enum {
    pub const NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS: nvmlRestrictedAPI_enum =
        nvmlRestrictedAPI_enum(0);
}
impl nvmlRestrictedAPI_enum {
    pub const NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS: nvmlRestrictedAPI_enum =
        nvmlRestrictedAPI_enum(1);
}
impl nvmlRestrictedAPI_enum {
    pub const NVML_RESTRICTED_API_COUNT: nvmlRestrictedAPI_enum = nvmlRestrictedAPI_enum(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlRestrictedAPI_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlRestrictedAPI_enum as nvmlRestrictedAPI_t;
impl nvmlGpuVirtualizationMode {
    pub const NVML_GPU_VIRTUALIZATION_MODE_NONE: nvmlGpuVirtualizationMode =
        nvmlGpuVirtualizationMode(0);
}
impl nvmlGpuVirtualizationMode {
    pub const NVML_GPU_VIRTUALIZATION_MODE_PASSTHROUGH: nvmlGpuVirtualizationMode =
        nvmlGpuVirtualizationMode(1);
}
impl nvmlGpuVirtualizationMode {
    pub const NVML_GPU_VIRTUALIZATION_MODE_VGPU: nvmlGpuVirtualizationMode =
        nvmlGpuVirtualizationMode(2);
}
impl nvmlGpuVirtualizationMode {
    pub const NVML_GPU_VIRTUALIZATION_MODE_HOST_VGPU: nvmlGpuVirtualizationMode =
        nvmlGpuVirtualizationMode(3);
}
impl nvmlGpuVirtualizationMode {
    pub const NVML_GPU_VIRTUALIZATION_MODE_HOST_VSGA: nvmlGpuVirtualizationMode =
        nvmlGpuVirtualizationMode(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlGpuVirtualizationMode(pub ::std::os::raw::c_uint);
pub use self::nvmlGpuVirtualizationMode as nvmlGpuVirtualizationMode_t;
impl nvmlHostVgpuMode_enum {
    pub const NVML_HOST_VGPU_MODE_NON_SRIOV: nvmlHostVgpuMode_enum = nvmlHostVgpuMode_enum(0);
}
impl nvmlHostVgpuMode_enum {
    pub const NVML_HOST_VGPU_MODE_SRIOV: nvmlHostVgpuMode_enum = nvmlHostVgpuMode_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlHostVgpuMode_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlHostVgpuMode_enum as nvmlHostVgpuMode_t;
impl nvmlVgpuVmIdType {
    pub const NVML_VGPU_VM_ID_DOMAIN_ID: nvmlVgpuVmIdType = nvmlVgpuVmIdType(0);
}
impl nvmlVgpuVmIdType {
    pub const NVML_VGPU_VM_ID_UUID: nvmlVgpuVmIdType = nvmlVgpuVmIdType(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlVgpuVmIdType(pub ::std::os::raw::c_uint);
pub use self::nvmlVgpuVmIdType as nvmlVgpuVmIdType_t;
impl nvmlVgpuGuestInfoState_enum {
    pub const NVML_VGPU_INSTANCE_GUEST_INFO_STATE_UNINITIALIZED: nvmlVgpuGuestInfoState_enum =
        nvmlVgpuGuestInfoState_enum(0);
}
impl nvmlVgpuGuestInfoState_enum {
    pub const NVML_VGPU_INSTANCE_GUEST_INFO_STATE_INITIALIZED: nvmlVgpuGuestInfoState_enum =
        nvmlVgpuGuestInfoState_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlVgpuGuestInfoState_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlVgpuGuestInfoState_enum as nvmlVgpuGuestInfoState_t;
impl nvmlGridLicenseFeatureCode_t {
    pub const NVML_GRID_LICENSE_FEATURE_CODE_UNKNOWN: nvmlGridLicenseFeatureCode_t =
        nvmlGridLicenseFeatureCode_t(0);
}
impl nvmlGridLicenseFeatureCode_t {
    pub const NVML_GRID_LICENSE_FEATURE_CODE_VGPU: nvmlGridLicenseFeatureCode_t =
        nvmlGridLicenseFeatureCode_t(1);
}
impl nvmlGridLicenseFeatureCode_t {
    pub const NVML_GRID_LICENSE_FEATURE_CODE_NVIDIA_RTX: nvmlGridLicenseFeatureCode_t =
        nvmlGridLicenseFeatureCode_t(2);
}
impl nvmlGridLicenseFeatureCode_t {
    pub const NVML_GRID_LICENSE_FEATURE_CODE_VWORKSTATION: nvmlGridLicenseFeatureCode_t =
        nvmlGridLicenseFeatureCode_t(2);
}
impl nvmlGridLicenseFeatureCode_t {
    pub const NVML_GRID_LICENSE_FEATURE_CODE_GAMING: nvmlGridLicenseFeatureCode_t =
        nvmlGridLicenseFeatureCode_t(3);
}
impl nvmlGridLicenseFeatureCode_t {
    pub const NVML_GRID_LICENSE_FEATURE_CODE_COMPUTE: nvmlGridLicenseFeatureCode_t =
        nvmlGridLicenseFeatureCode_t(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlGridLicenseFeatureCode_t(pub ::std::os::raw::c_uint);
impl nvmlVgpuCapability_enum {
    pub const NVML_VGPU_CAP_NVLINK_P2P: nvmlVgpuCapability_enum = nvmlVgpuCapability_enum(0);
}
impl nvmlVgpuCapability_enum {
    pub const NVML_VGPU_CAP_GPUDIRECT: nvmlVgpuCapability_enum = nvmlVgpuCapability_enum(1);
}
impl nvmlVgpuCapability_enum {
    pub const NVML_VGPU_CAP_MULTI_VGPU_EXCLUSIVE: nvmlVgpuCapability_enum =
        nvmlVgpuCapability_enum(2);
}
impl nvmlVgpuCapability_enum {
    pub const NVML_VGPU_CAP_EXCLUSIVE_TYPE: nvmlVgpuCapability_enum = nvmlVgpuCapability_enum(3);
}
impl nvmlVgpuCapability_enum {
    pub const NVML_VGPU_CAP_EXCLUSIVE_SIZE: nvmlVgpuCapability_enum = nvmlVgpuCapability_enum(4);
}
impl nvmlVgpuCapability_enum {
    pub const NVML_VGPU_CAP_COUNT: nvmlVgpuCapability_enum = nvmlVgpuCapability_enum(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlVgpuCapability_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlVgpuCapability_enum as nvmlVgpuCapability_t;
impl nvmlVgpuDriverCapability_enum {
    pub const NVML_VGPU_DRIVER_CAP_HETEROGENEOUS_MULTI_VGPU: nvmlVgpuDriverCapability_enum =
        nvmlVgpuDriverCapability_enum(0);
}
impl nvmlVgpuDriverCapability_enum {
    pub const NVML_VGPU_DRIVER_CAP_COUNT: nvmlVgpuDriverCapability_enum =
        nvmlVgpuDriverCapability_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlVgpuDriverCapability_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlVgpuDriverCapability_enum as nvmlVgpuDriverCapability_t;
impl nvmlDeviceVgpuCapability_enum {
    pub const NVML_DEVICE_VGPU_CAP_FRACTIONAL_MULTI_VGPU: nvmlDeviceVgpuCapability_enum =
        nvmlDeviceVgpuCapability_enum(0);
}
impl nvmlDeviceVgpuCapability_enum {
    pub const NVML_DEVICE_VGPU_CAP_HETEROGENEOUS_TIMESLICE_PROFILES: nvmlDeviceVgpuCapability_enum =
        nvmlDeviceVgpuCapability_enum(1);
}
impl nvmlDeviceVgpuCapability_enum {
    pub const NVML_DEVICE_VGPU_CAP_HETEROGENEOUS_TIMESLICE_SIZES: nvmlDeviceVgpuCapability_enum =
        nvmlDeviceVgpuCapability_enum(2);
}
impl nvmlDeviceVgpuCapability_enum {
    pub const NVML_DEVICE_VGPU_CAP_READ_DEVICE_BUFFER_BW: nvmlDeviceVgpuCapability_enum =
        nvmlDeviceVgpuCapability_enum(3);
}
impl nvmlDeviceVgpuCapability_enum {
    pub const NVML_DEVICE_VGPU_CAP_WRITE_DEVICE_BUFFER_BW: nvmlDeviceVgpuCapability_enum =
        nvmlDeviceVgpuCapability_enum(4);
}
impl nvmlDeviceVgpuCapability_enum {
    pub const NVML_DEVICE_VGPU_CAP_COUNT: nvmlDeviceVgpuCapability_enum =
        nvmlDeviceVgpuCapability_enum(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlDeviceVgpuCapability_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlDeviceVgpuCapability_enum as nvmlDeviceVgpuCapability_t;
pub type nvmlVgpuTypeId_t = ::std::os::raw::c_uint;
pub type nvmlVgpuInstance_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuInstanceUtilizationSample_st {
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub timeStamp: ::std::os::raw::c_ulonglong,
    pub smUtil: nvmlValue_t,
    pub memUtil: nvmlValue_t,
    pub encUtil: nvmlValue_t,
    pub decUtil: nvmlValue_t,
}
pub type nvmlVgpuInstanceUtilizationSample_t = nvmlVgpuInstanceUtilizationSample_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuProcessUtilizationSample_st {
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub pid: ::std::os::raw::c_uint,
    pub processName: [::std::os::raw::c_char; 64usize],
    pub timeStamp: ::std::os::raw::c_ulonglong,
    pub smUtil: ::std::os::raw::c_uint,
    pub memUtil: ::std::os::raw::c_uint,
    pub encUtil: ::std::os::raw::c_uint,
    pub decUtil: ::std::os::raw::c_uint,
}
pub type nvmlVgpuProcessUtilizationSample_t = nvmlVgpuProcessUtilizationSample_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvmlVgpuSchedulerParams_t {
    pub vgpuSchedDataWithARR: nvmlVgpuSchedulerParams_t__bindgen_ty_1,
    pub vgpuSchedData: nvmlVgpuSchedulerParams_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuSchedulerParams_t__bindgen_ty_1 {
    pub avgFactor: ::std::os::raw::c_uint,
    pub timeslice: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuSchedulerParams_t__bindgen_ty_2 {
    pub timeslice: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuSchedulerLogEntries_st {
    pub timestamp: ::std::os::raw::c_ulonglong,
    pub timeRunTotal: ::std::os::raw::c_ulonglong,
    pub timeRun: ::std::os::raw::c_ulonglong,
    pub swRunlistId: ::std::os::raw::c_uint,
    pub targetTimeSlice: ::std::os::raw::c_ulonglong,
    pub cumulativePreemptionTime: ::std::os::raw::c_ulonglong,
}
pub type nvmlVgpuSchedulerLogEntry_t = nvmlVgpuSchedulerLogEntries_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuSchedulerLog_st {
    pub engineId: ::std::os::raw::c_uint,
    pub schedulerPolicy: ::std::os::raw::c_uint,
    pub isEnabledARR: ::std::os::raw::c_uint,
    pub schedulerParams: nvmlVgpuSchedulerParams_t,
    pub entriesCount: ::std::os::raw::c_uint,
    pub logEntries: [nvmlVgpuSchedulerLogEntry_t; 200usize],
}
pub type nvmlVgpuSchedulerLog_t = nvmlVgpuSchedulerLog_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuSchedulerGetState_st {
    pub schedulerPolicy: ::std::os::raw::c_uint,
    pub isEnabledARR: ::std::os::raw::c_uint,
    pub schedulerParams: nvmlVgpuSchedulerParams_t,
}
pub type nvmlVgpuSchedulerGetState_t = nvmlVgpuSchedulerGetState_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvmlVgpuSchedulerSetParams_t {
    pub vgpuSchedDataWithARR: nvmlVgpuSchedulerSetParams_t__bindgen_ty_1,
    pub vgpuSchedData: nvmlVgpuSchedulerSetParams_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuSchedulerSetParams_t__bindgen_ty_1 {
    pub avgFactor: ::std::os::raw::c_uint,
    pub frequency: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuSchedulerSetParams_t__bindgen_ty_2 {
    pub timeslice: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuSchedulerSetState_st {
    pub schedulerPolicy: ::std::os::raw::c_uint,
    pub enableARRMode: ::std::os::raw::c_uint,
    pub schedulerParams: nvmlVgpuSchedulerSetParams_t,
}
pub type nvmlVgpuSchedulerSetState_t = nvmlVgpuSchedulerSetState_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuSchedulerCapabilities_st {
    pub supportedSchedulers: [::std::os::raw::c_uint; 3usize],
    pub maxTimeslice: ::std::os::raw::c_uint,
    pub minTimeslice: ::std::os::raw::c_uint,
    pub isArrModeSupported: ::std::os::raw::c_uint,
    pub maxFrequencyForARR: ::std::os::raw::c_uint,
    pub minFrequencyForARR: ::std::os::raw::c_uint,
    pub maxAvgFactorForARR: ::std::os::raw::c_uint,
    pub minAvgFactorForARR: ::std::os::raw::c_uint,
}
pub type nvmlVgpuSchedulerCapabilities_t = nvmlVgpuSchedulerCapabilities_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuLicenseExpiry_st {
    pub year: ::std::os::raw::c_uint,
    pub month: ::std::os::raw::c_ushort,
    pub day: ::std::os::raw::c_ushort,
    pub hour: ::std::os::raw::c_ushort,
    pub min: ::std::os::raw::c_ushort,
    pub sec: ::std::os::raw::c_ushort,
    pub status: ::std::os::raw::c_uchar,
}
pub type nvmlVgpuLicenseExpiry_t = nvmlVgpuLicenseExpiry_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuLicenseInfo_st {
    pub isLicensed: ::std::os::raw::c_uchar,
    pub licenseExpiry: nvmlVgpuLicenseExpiry_t,
    pub currentState: ::std::os::raw::c_uint,
}
pub type nvmlVgpuLicenseInfo_t = nvmlVgpuLicenseInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlProcessUtilizationSample_st {
    pub pid: ::std::os::raw::c_uint,
    pub timeStamp: ::std::os::raw::c_ulonglong,
    pub smUtil: ::std::os::raw::c_uint,
    pub memUtil: ::std::os::raw::c_uint,
    pub encUtil: ::std::os::raw::c_uint,
    pub decUtil: ::std::os::raw::c_uint,
}
pub type nvmlProcessUtilizationSample_t = nvmlProcessUtilizationSample_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGridLicenseExpiry_st {
    pub year: ::std::os::raw::c_uint,
    pub month: ::std::os::raw::c_ushort,
    pub day: ::std::os::raw::c_ushort,
    pub hour: ::std::os::raw::c_ushort,
    pub min: ::std::os::raw::c_ushort,
    pub sec: ::std::os::raw::c_ushort,
    pub status: ::std::os::raw::c_uchar,
}
pub type nvmlGridLicenseExpiry_t = nvmlGridLicenseExpiry_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGridLicensableFeature_st {
    pub featureCode: nvmlGridLicenseFeatureCode_t,
    pub featureState: ::std::os::raw::c_uint,
    pub licenseInfo: [::std::os::raw::c_char; 128usize],
    pub productName: [::std::os::raw::c_char; 128usize],
    pub featureEnabled: ::std::os::raw::c_uint,
    pub licenseExpiry: nvmlGridLicenseExpiry_t,
}
pub type nvmlGridLicensableFeature_t = nvmlGridLicensableFeature_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGridLicensableFeatures_st {
    pub isGridLicenseSupported: ::std::os::raw::c_int,
    pub licensableFeaturesCount: ::std::os::raw::c_uint,
    pub gridLicensableFeatures: [nvmlGridLicensableFeature_t; 3usize],
}
pub type nvmlGridLicensableFeatures_t = nvmlGridLicensableFeatures_st;
pub type nvmlDeviceArchitecture_t = ::std::os::raw::c_uint;
pub type nvmlBusType_t = ::std::os::raw::c_uint;
pub type nvmlFanControlPolicy_t = ::std::os::raw::c_uint;
pub type nvmlPowerSource_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuDynamicPstatesInfo_st {
    pub flags: ::std::os::raw::c_uint,
    pub utilization: [nvmlGpuDynamicPstatesInfo_st__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuDynamicPstatesInfo_st__bindgen_ty_1 {
    pub bIsPresent: ::std::os::raw::c_uint,
    pub percentage: ::std::os::raw::c_uint,
    pub incThreshold: ::std::os::raw::c_uint,
    pub decThreshold: ::std::os::raw::c_uint,
}
pub type nvmlGpuDynamicPstatesInfo_t = nvmlGpuDynamicPstatesInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlFieldValue_st {
    pub fieldId: ::std::os::raw::c_uint,
    pub scopeId: ::std::os::raw::c_uint,
    pub timestamp: ::std::os::raw::c_longlong,
    pub latencyUsec: ::std::os::raw::c_longlong,
    pub valueType: nvmlValueType_t,
    pub nvmlReturn: nvmlReturn_t,
    pub value: nvmlValue_t,
}
pub type nvmlFieldValue_t = nvmlFieldValue_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUnit_st {
    _unused: [u8; 0],
}
pub type nvmlUnit_t = *mut nvmlUnit_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlHwbcEntry_st {
    pub hwbcId: ::std::os::raw::c_uint,
    pub firmwareVersion: [::std::os::raw::c_char; 32usize],
}
pub type nvmlHwbcEntry_t = nvmlHwbcEntry_st;
impl nvmlFanState_enum {
    pub const NVML_FAN_NORMAL: nvmlFanState_enum = nvmlFanState_enum(0);
}
impl nvmlFanState_enum {
    pub const NVML_FAN_FAILED: nvmlFanState_enum = nvmlFanState_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlFanState_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlFanState_enum as nvmlFanState_t;
impl nvmlLedColor_enum {
    pub const NVML_LED_COLOR_GREEN: nvmlLedColor_enum = nvmlLedColor_enum(0);
}
impl nvmlLedColor_enum {
    pub const NVML_LED_COLOR_AMBER: nvmlLedColor_enum = nvmlLedColor_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlLedColor_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlLedColor_enum as nvmlLedColor_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlLedState_st {
    pub cause: [::std::os::raw::c_char; 256usize],
    pub color: nvmlLedColor_t,
}
pub type nvmlLedState_t = nvmlLedState_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUnitInfo_st {
    pub name: [::std::os::raw::c_char; 96usize],
    pub id: [::std::os::raw::c_char; 96usize],
    pub serial: [::std::os::raw::c_char; 96usize],
    pub firmwareVersion: [::std::os::raw::c_char; 96usize],
}
pub type nvmlUnitInfo_t = nvmlUnitInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlPSUInfo_st {
    pub state: [::std::os::raw::c_char; 256usize],
    pub current: ::std::os::raw::c_uint,
    pub voltage: ::std::os::raw::c_uint,
    pub power: ::std::os::raw::c_uint,
}
pub type nvmlPSUInfo_t = nvmlPSUInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUnitFanInfo_st {
    pub speed: ::std::os::raw::c_uint,
    pub state: nvmlFanState_t,
}
pub type nvmlUnitFanInfo_t = nvmlUnitFanInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUnitFanSpeeds_st {
    pub fans: [nvmlUnitFanInfo_t; 24usize],
    pub count: ::std::os::raw::c_uint,
}
pub type nvmlUnitFanSpeeds_t = nvmlUnitFanSpeeds_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlEventSet_st {
    _unused: [u8; 0],
}
pub type nvmlEventSet_t = *mut nvmlEventSet_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlEventData_st {
    pub device: nvmlDevice_t,
    pub eventType: ::std::os::raw::c_ulonglong,
    pub eventData: ::std::os::raw::c_ulonglong,
    pub gpuInstanceId: ::std::os::raw::c_uint,
    pub computeInstanceId: ::std::os::raw::c_uint,
}
pub type nvmlEventData_t = nvmlEventData_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlAccountingStats_st {
    pub gpuUtilization: ::std::os::raw::c_uint,
    pub memoryUtilization: ::std::os::raw::c_uint,
    pub maxMemoryUsage: ::std::os::raw::c_ulonglong,
    pub time: ::std::os::raw::c_ulonglong,
    pub startTime: ::std::os::raw::c_ulonglong,
    pub isRunning: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 5usize],
}
pub type nvmlAccountingStats_t = nvmlAccountingStats_st;
impl nvmlEncoderQueryType_enum {
    pub const NVML_ENCODER_QUERY_H264: nvmlEncoderQueryType_enum = nvmlEncoderQueryType_enum(0);
}
impl nvmlEncoderQueryType_enum {
    pub const NVML_ENCODER_QUERY_HEVC: nvmlEncoderQueryType_enum = nvmlEncoderQueryType_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlEncoderQueryType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlEncoderQueryType_enum as nvmlEncoderType_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlEncoderSessionInfo_st {
    pub sessionId: ::std::os::raw::c_uint,
    pub pid: ::std::os::raw::c_uint,
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub codecType: nvmlEncoderType_t,
    pub hResolution: ::std::os::raw::c_uint,
    pub vResolution: ::std::os::raw::c_uint,
    pub averageFps: ::std::os::raw::c_uint,
    pub averageLatency: ::std::os::raw::c_uint,
}
pub type nvmlEncoderSessionInfo_t = nvmlEncoderSessionInfo_st;
impl nvmlFBCSessionType_enum {
    pub const NVML_FBC_SESSION_TYPE_UNKNOWN: nvmlFBCSessionType_enum = nvmlFBCSessionType_enum(0);
}
impl nvmlFBCSessionType_enum {
    pub const NVML_FBC_SESSION_TYPE_TOSYS: nvmlFBCSessionType_enum = nvmlFBCSessionType_enum(1);
}
impl nvmlFBCSessionType_enum {
    pub const NVML_FBC_SESSION_TYPE_CUDA: nvmlFBCSessionType_enum = nvmlFBCSessionType_enum(2);
}
impl nvmlFBCSessionType_enum {
    pub const NVML_FBC_SESSION_TYPE_VID: nvmlFBCSessionType_enum = nvmlFBCSessionType_enum(3);
}
impl nvmlFBCSessionType_enum {
    pub const NVML_FBC_SESSION_TYPE_HWENC: nvmlFBCSessionType_enum = nvmlFBCSessionType_enum(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlFBCSessionType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlFBCSessionType_enum as nvmlFBCSessionType_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlFBCStats_st {
    pub sessionsCount: ::std::os::raw::c_uint,
    pub averageFPS: ::std::os::raw::c_uint,
    pub averageLatency: ::std::os::raw::c_uint,
}
pub type nvmlFBCStats_t = nvmlFBCStats_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlFBCSessionInfo_st {
    pub sessionId: ::std::os::raw::c_uint,
    pub pid: ::std::os::raw::c_uint,
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub displayOrdinal: ::std::os::raw::c_uint,
    pub sessionType: nvmlFBCSessionType_t,
    pub sessionFlags: ::std::os::raw::c_uint,
    pub hMaxResolution: ::std::os::raw::c_uint,
    pub vMaxResolution: ::std::os::raw::c_uint,
    pub hResolution: ::std::os::raw::c_uint,
    pub vResolution: ::std::os::raw::c_uint,
    pub averageFPS: ::std::os::raw::c_uint,
    pub averageLatency: ::std::os::raw::c_uint,
}
pub type nvmlFBCSessionInfo_t = nvmlFBCSessionInfo_st;
impl nvmlDetachGpuState_enum {
    pub const NVML_DETACH_GPU_KEEP: nvmlDetachGpuState_enum = nvmlDetachGpuState_enum(0);
}
impl nvmlDetachGpuState_enum {
    pub const NVML_DETACH_GPU_REMOVE: nvmlDetachGpuState_enum = nvmlDetachGpuState_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlDetachGpuState_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlDetachGpuState_enum as nvmlDetachGpuState_t;
impl nvmlPcieLinkState_enum {
    pub const NVML_PCIE_LINK_KEEP: nvmlPcieLinkState_enum = nvmlPcieLinkState_enum(0);
}
impl nvmlPcieLinkState_enum {
    pub const NVML_PCIE_LINK_SHUT_DOWN: nvmlPcieLinkState_enum = nvmlPcieLinkState_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlPcieLinkState_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlPcieLinkState_enum as nvmlPcieLinkState_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlConfComputeSystemCaps_st {
    pub cpuCaps: ::std::os::raw::c_uint,
    pub gpusCaps: ::std::os::raw::c_uint,
}
pub type nvmlConfComputeSystemCaps_t = nvmlConfComputeSystemCaps_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlConfComputeSystemState_st {
    pub environment: ::std::os::raw::c_uint,
    pub ccFeature: ::std::os::raw::c_uint,
    pub devToolsMode: ::std::os::raw::c_uint,
}
pub type nvmlConfComputeSystemState_t = nvmlConfComputeSystemState_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlConfComputeMemSizeInfo_st {
    pub protectedMemSizeKib: ::std::os::raw::c_ulonglong,
    pub unprotectedMemSizeKib: ::std::os::raw::c_ulonglong,
}
pub type nvmlConfComputeMemSizeInfo_t = nvmlConfComputeMemSizeInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlConfComputeGpuCertificate_st {
    pub certChainSize: ::std::os::raw::c_uint,
    pub attestationCertChainSize: ::std::os::raw::c_uint,
    pub certChain: [::std::os::raw::c_uchar; 4096usize],
    pub attestationCertChain: [::std::os::raw::c_uchar; 5120usize],
}
pub type nvmlConfComputeGpuCertificate_t = nvmlConfComputeGpuCertificate_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlConfComputeGpuAttestationReport_st {
    pub isCecAttestationReportPresent: ::std::os::raw::c_uint,
    pub attestationReportSize: ::std::os::raw::c_uint,
    pub cecAttestationReportSize: ::std::os::raw::c_uint,
    pub nonce: [::std::os::raw::c_uchar; 32usize],
    pub attestationReport: [::std::os::raw::c_uchar; 8192usize],
    pub cecAttestationReport: [::std::os::raw::c_uchar; 4096usize],
}
pub type nvmlConfComputeGpuAttestationReport_t = nvmlConfComputeGpuAttestationReport_st;
pub type nvmlGpuFabricState_t = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuFabricInfo_t {
    pub clusterUuid: [::std::os::raw::c_char; 16usize],
    pub status: nvmlReturn_t,
    pub partitionId: ::std::os::raw::c_uint,
    pub state: nvmlGpuFabricState_t,
}
pub type nvmlPowerScopeType_t = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlPowerValue_v2_t {
    pub version: ::std::os::raw::c_uint,
    pub powerScope: nvmlPowerScopeType_t,
    pub powerValueMw: ::std::os::raw::c_uint,
}

#[no_mangle]
pub extern "C" fn nvmlInit_v2() -> nvmlReturn_t {
    unsafe { crate::r#impl::init().into() }
}

#[no_mangle]
pub extern "C" fn nvmlInitWithFlags(flags: ::std::os::raw::c_uint) -> nvmlReturn_t {
    unsafe { crate::r#impl::init_with_flags(flags).into() }
}

#[no_mangle]
pub extern "C" fn nvmlShutdown() -> nvmlReturn_t {
    unsafe { crate::r#impl::shutdown() }
}

#[no_mangle]
pub extern "C" fn nvmlErrorString(result: nvmlReturn_t) -> *const ::std::os::raw::c_char {
    crate::common::error_string(result)
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetDriverVersion(
    version: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    unsafe { crate::common::system_get_driver_version(version, length).into() }
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetNVMLVersion(
    version: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    unsafe { crate::common::system_get_nvml_version(version, length).into() }
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetCudaDriverVersion(
    cudaDriverVersion: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    unsafe { crate::common::system_get_cuda_driver_version(cudaDriverVersion).into() }
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetCudaDriverVersion_v2(
    cudaDriverVersion: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    unsafe { crate::common::system_get_cuda_driver_version(cudaDriverVersion).into() }
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetProcessName(
    pid: ::std::os::raw::c_uint,
    name: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetCount(unitCount: *mut ::std::os::raw::c_uint) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetHandleByIndex(
    index: ::std::os::raw::c_uint,
    unit: *mut nvmlUnit_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetUnitInfo(unit: nvmlUnit_t, info: *mut nvmlUnitInfo_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetLedState(
    unit: nvmlUnit_t,
    state: *mut nvmlLedState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetPsuInfo(unit: nvmlUnit_t, psu: *mut nvmlPSUInfo_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetTemperature(
    unit: nvmlUnit_t,
    type_: ::std::os::raw::c_uint,
    temp: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetFanSpeedInfo(
    unit: nvmlUnit_t,
    fanSpeeds: *mut nvmlUnitFanSpeeds_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetDevices(
    unit: nvmlUnit_t,
    deviceCount: *mut ::std::os::raw::c_uint,
    devices: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetHicVersion(
    hwbcCount: *mut ::std::os::raw::c_uint,
    hwbcEntries: *mut nvmlHwbcEntry_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCount_v2(deviceCount: *mut ::std::os::raw::c_uint) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_count(deviceCount) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAttributes_v2(
    device: nvmlDevice_t,
    attributes: *mut nvmlDeviceAttributes_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetHandleByIndex_v2(
    index: ::std::os::raw::c_uint,
    device: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_handle_by_index(index, device) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetHandleBySerial(
    serial: *const ::std::os::raw::c_char,
    device: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetHandleByUUID(
    uuid: *const ::std::os::raw::c_char,
    device: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetHandleByPciBusId_v2(
    pciBusId: *const ::std::os::raw::c_char,
    device: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_handle_by_pci_bus_id(pciBusId, device) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetName(
    device: nvmlDevice_t,
    name: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetBrand(
    device: nvmlDevice_t,
    type_: *mut nvmlBrandType_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetIndex(
    device: nvmlDevice_t,
    index: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSerial(
    device: nvmlDevice_t,
    serial: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetModuleId(
    device: nvmlDevice_t,
    moduleId: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}
pub type nvmlAffinityScope_t = ::std::os::raw::c_uint;

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMemoryAffinity(
    device: nvmlDevice_t,
    nodeSetSize: ::std::os::raw::c_uint,
    nodeSet: *mut ::std::os::raw::c_ulong,
    scope: nvmlAffinityScope_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCpuAffinityWithinScope(
    device: nvmlDevice_t,
    cpuSetSize: ::std::os::raw::c_uint,
    cpuSet: *mut ::std::os::raw::c_ulong,
    scope: nvmlAffinityScope_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCpuAffinity(
    device: nvmlDevice_t,
    cpuSetSize: ::std::os::raw::c_uint,
    cpuSet: *mut ::std::os::raw::c_ulong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceClearCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTopologyCommonAncestor(
    device1: nvmlDevice_t,
    device2: nvmlDevice_t,
    pathInfo: *mut nvmlGpuTopologyLevel_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTopologyNearestGpus(
    device: nvmlDevice_t,
    level: nvmlGpuTopologyLevel_t,
    count: *mut ::std::os::raw::c_uint,
    deviceArray: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetTopologyGpuSet(
    cpuNumber: ::std::os::raw::c_uint,
    count: *mut ::std::os::raw::c_uint,
    deviceArray: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetP2PStatus(
    device1: nvmlDevice_t,
    device2: nvmlDevice_t,
    p2pIndex: nvmlGpuP2PCapsIndex_t,
    p2pStatus: *mut nvmlGpuP2PStatus_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetUUID(
    device: nvmlDevice_t,
    uuid: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetMdevUUID(
    vgpuInstance: nvmlVgpuInstance_t,
    mdevUuid: *mut ::std::os::raw::c_char,
    size: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMinorNumber(
    device: nvmlDevice_t,
    minorNumber: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetBoardPartNumber(
    device: nvmlDevice_t,
    partNumber: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetInforomVersion(
    device: nvmlDevice_t,
    object: nvmlInforomObject_t,
    version: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetInforomImageVersion(
    device: nvmlDevice_t,
    version: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetInforomConfigurationChecksum(
    device: nvmlDevice_t,
    checksum: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceValidateInforom(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDisplayMode(
    device: nvmlDevice_t,
    display: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDisplayActive(
    device: nvmlDevice_t,
    isActive: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPersistenceMode(
    device: nvmlDevice_t,
    mode: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPciInfo_v3(
    device: nvmlDevice_t,
    pci: *mut nvmlPciInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMaxPcieLinkGeneration(
    device: nvmlDevice_t,
    maxLinkGen: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuMaxPcieLinkGeneration(
    device: nvmlDevice_t,
    maxLinkGenDevice: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMaxPcieLinkWidth(
    device: nvmlDevice_t,
    maxLinkWidth: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCurrPcieLinkGeneration(
    device: nvmlDevice_t,
    currLinkGen: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCurrPcieLinkWidth(
    device: nvmlDevice_t,
    currLinkWidth: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPcieThroughput(
    device: nvmlDevice_t,
    counter: nvmlPcieUtilCounter_t,
    value: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_pcie_throughput(device, counter, value) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPcieReplayCounter(
    device: nvmlDevice_t,
    value: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetClockInfo(
    device: nvmlDevice_t,
    type_: nvmlClockType_t,
    clock: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMaxClockInfo(
    device: nvmlDevice_t,
    type_: nvmlClockType_t,
    clock: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpcClkVfOffset(
    device: nvmlDevice_t,
    offset: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetApplicationsClock(
    device: nvmlDevice_t,
    clockType: nvmlClockType_t,
    clockMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDefaultApplicationsClock(
    device: nvmlDevice_t,
    clockType: nvmlClockType_t,
    clockMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceResetApplicationsClocks(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetClock(
    device: nvmlDevice_t,
    clockType: nvmlClockType_t,
    clockId: nvmlClockId_t,
    clockMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMaxCustomerBoostClock(
    device: nvmlDevice_t,
    clockType: nvmlClockType_t,
    clockMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSupportedMemoryClocks(
    device: nvmlDevice_t,
    count: *mut ::std::os::raw::c_uint,
    clocksMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSupportedGraphicsClocks(
    device: nvmlDevice_t,
    memoryClockMHz: ::std::os::raw::c_uint,
    count: *mut ::std::os::raw::c_uint,
    clocksMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAutoBoostedClocksEnabled(
    device: nvmlDevice_t,
    isEnabled: *mut nvmlEnableState_t,
    defaultIsEnabled: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetAutoBoostedClocksEnabled(
    device: nvmlDevice_t,
    enabled: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetDefaultAutoBoostedClocksEnabled(
    device: nvmlDevice_t,
    enabled: nvmlEnableState_t,
    flags: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetFanSpeed(
    device: nvmlDevice_t,
    speed: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_fan_speed(device, speed).into() }
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetFanSpeed_v2(
    device: nvmlDevice_t,
    fan: ::std::os::raw::c_uint,
    speed: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTargetFanSpeed(
    device: nvmlDevice_t,
    fan: ::std::os::raw::c_uint,
    targetSpeed: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetDefaultFanSpeed_v2(
    device: nvmlDevice_t,
    fan: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMinMaxFanSpeed(
    device: nvmlDevice_t,
    minSpeed: *mut ::std::os::raw::c_uint,
    maxSpeed: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetFanControlPolicy_v2(
    device: nvmlDevice_t,
    fan: ::std::os::raw::c_uint,
    policy: *mut nvmlFanControlPolicy_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetFanControlPolicy(
    device: nvmlDevice_t,
    fan: ::std::os::raw::c_uint,
    policy: nvmlFanControlPolicy_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNumFans(
    device: nvmlDevice_t,
    numFans: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTemperature(
    device: nvmlDevice_t,
    sensorType: nvmlTemperatureSensors_t,
    temp: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_temperature(device, sensorType, temp) }
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTemperatureThreshold(
    device: nvmlDevice_t,
    thresholdType: nvmlTemperatureThresholds_t,
    temp: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    unsafe { crate::common::device_get_temperature_threshold(device, thresholdType, temp) }
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetTemperatureThreshold(
    device: nvmlDevice_t,
    thresholdType: nvmlTemperatureThresholds_t,
    temp: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetThermalSettings(
    device: nvmlDevice_t,
    sensorIndex: ::std::os::raw::c_uint,
    pThermalSettings: *mut nvmlGpuThermalSettings_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPerformanceState(
    device: nvmlDevice_t,
    pState: *mut nvmlPstates_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCurrentClocksEventReasons(
    device: nvmlDevice_t,
    clocksEventReasons: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCurrentClocksThrottleReasons(
    device: nvmlDevice_t,
    clocksThrottleReasons: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSupportedClocksEventReasons(
    device: nvmlDevice_t,
    supportedClocksEventReasons: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSupportedClocksThrottleReasons(
    device: nvmlDevice_t,
    supportedClocksThrottleReasons: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerState(
    device: nvmlDevice_t,
    pState: *mut nvmlPstates_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDynamicPstatesInfo(
    device: nvmlDevice_t,
    pDynamicPstatesInfo: *mut nvmlGpuDynamicPstatesInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMemClkVfOffset(
    device: nvmlDevice_t,
    offset: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMinMaxClockOfPState(
    device: nvmlDevice_t,
    type_: nvmlClockType_t,
    pstate: nvmlPstates_t,
    minClockMHz: *mut ::std::os::raw::c_uint,
    maxClockMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSupportedPerformanceStates(
    device: nvmlDevice_t,
    pstates: *mut nvmlPstates_t,
    size: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpcClkMinMaxVfOffset(
    device: nvmlDevice_t,
    minOffset: *mut ::std::os::raw::c_int,
    maxOffset: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMemClkMinMaxVfOffset(
    device: nvmlDevice_t,
    minOffset: *mut ::std::os::raw::c_int,
    maxOffset: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerManagementMode(
    device: nvmlDevice_t,
    mode: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerManagementLimit(
    device: nvmlDevice_t,
    limit: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_power_management_limit(device, limit) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerManagementLimitConstraints(
    device: nvmlDevice_t,
    minLimit: *mut ::std::os::raw::c_uint,
    maxLimit: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_power_management_limit_constraints(device, minLimit, maxLimit) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerManagementDefaultLimit(
    device: nvmlDevice_t,
    defaultLimit: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_power_management_limit(device, defaultLimit) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerUsage(
    device: nvmlDevice_t,
    power: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_power_usage(device, power) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTotalEnergyConsumption(
    device: nvmlDevice_t,
    energy: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetEnforcedPowerLimit(
    device: nvmlDevice_t,
    limit: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuOperationMode(
    device: nvmlDevice_t,
    current: *mut nvmlGpuOperationMode_t,
    pending: *mut nvmlGpuOperationMode_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMemoryInfo(
    device: nvmlDevice_t,
    memory: *mut nvmlMemory_t,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_memory_info(device, memory).into() }
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMemoryInfo_v2(
    device: nvmlDevice_t,
    memory: *mut nvmlMemory_v2_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetComputeMode(
    device: nvmlDevice_t,
    mode: *mut nvmlComputeMode_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCudaComputeCapability(
    device: nvmlDevice_t,
    major: *mut ::std::os::raw::c_int,
    minor: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    unsafe { crate::common::device_get_cuda_compute_capability(device, major, minor) }
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetEccMode(
    device: nvmlDevice_t,
    current: *mut nvmlEnableState_t,
    pending: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDefaultEccMode(
    device: nvmlDevice_t,
    defaultMode: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetBoardId(
    device: nvmlDevice_t,
    boardId: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMultiGpuBoard(
    device: nvmlDevice_t,
    multiGpuBool: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTotalEccErrors(
    device: nvmlDevice_t,
    errorType: nvmlMemoryErrorType_t,
    counterType: nvmlEccCounterType_t,
    eccCounts: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDetailedEccErrors(
    device: nvmlDevice_t,
    errorType: nvmlMemoryErrorType_t,
    counterType: nvmlEccCounterType_t,
    eccCounts: *mut nvmlEccErrorCounts_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMemoryErrorCounter(
    device: nvmlDevice_t,
    errorType: nvmlMemoryErrorType_t,
    counterType: nvmlEccCounterType_t,
    locationType: nvmlMemoryLocation_t,
    count: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetUtilizationRates(
    device: nvmlDevice_t,
    utilization: *mut nvmlUtilization_t,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_utilization_rates(device, utilization).into() }
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetEncoderUtilization(
    device: nvmlDevice_t,
    utilization: *mut ::std::os::raw::c_uint,
    samplingPeriodUs: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetEncoderCapacity(
    device: nvmlDevice_t,
    encoderQueryType: nvmlEncoderType_t,
    encoderCapacity: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetEncoderStats(
    device: nvmlDevice_t,
    sessionCount: *mut ::std::os::raw::c_uint,
    averageFps: *mut ::std::os::raw::c_uint,
    averageLatency: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetEncoderSessions(
    device: nvmlDevice_t,
    sessionCount: *mut ::std::os::raw::c_uint,
    sessionInfos: *mut nvmlEncoderSessionInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDecoderUtilization(
    device: nvmlDevice_t,
    utilization: *mut ::std::os::raw::c_uint,
    samplingPeriodUs: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetJpgUtilization(
    device: nvmlDevice_t,
    utilization: *mut ::std::os::raw::c_uint,
    samplingPeriodUs: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetOfaUtilization(
    device: nvmlDevice_t,
    utilization: *mut ::std::os::raw::c_uint,
    samplingPeriodUs: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetFBCStats(
    device: nvmlDevice_t,
    fbcStats: *mut nvmlFBCStats_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetFBCSessions(
    device: nvmlDevice_t,
    sessionCount: *mut ::std::os::raw::c_uint,
    sessionInfo: *mut nvmlFBCSessionInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDriverModel(
    device: nvmlDevice_t,
    current: *mut nvmlDriverModel_t,
    pending: *mut nvmlDriverModel_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVbiosVersion(
    device: nvmlDevice_t,
    version: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetBridgeChipInfo(
    device: nvmlDevice_t,
    bridgeHierarchy: *mut nvmlBridgeChipHierarchy_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetComputeRunningProcesses_v3(
    device: nvmlDevice_t,
    infoCount: *mut ::std::os::raw::c_uint,
    infos: *mut nvmlProcessInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGraphicsRunningProcesses_v3(
    device: nvmlDevice_t,
    infoCount: *mut ::std::os::raw::c_uint,
    infos: *mut nvmlProcessInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMPSComputeRunningProcesses_v3(
    device: nvmlDevice_t,
    infoCount: *mut ::std::os::raw::c_uint,
    infos: *mut nvmlProcessInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceOnSameBoard(
    device1: nvmlDevice_t,
    device2: nvmlDevice_t,
    onSameBoard: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAPIRestriction(
    device: nvmlDevice_t,
    apiType: nvmlRestrictedAPI_t,
    isRestricted: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSamples(
    device: nvmlDevice_t,
    type_: nvmlSamplingType_t,
    lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
    sampleValType: *mut nvmlValueType_t,
    sampleCount: *mut ::std::os::raw::c_uint,
    samples: *mut nvmlSample_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetBAR1MemoryInfo(
    device: nvmlDevice_t,
    bar1Memory: *mut nvmlBAR1Memory_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetViolationStatus(
    device: nvmlDevice_t,
    perfPolicyType: nvmlPerfPolicyType_t,
    violTime: *mut nvmlViolationTime_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetIrqNum(
    device: nvmlDevice_t,
    irqNum: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNumGpuCores(
    device: nvmlDevice_t,
    numCores: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerSource(
    device: nvmlDevice_t,
    powerSource: *mut nvmlPowerSource_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMemoryBusWidth(
    device: nvmlDevice_t,
    busWidth: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPcieLinkMaxSpeed(
    device: nvmlDevice_t,
    maxSpeed: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPcieSpeed(
    device: nvmlDevice_t,
    pcieSpeed: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAdaptiveClockInfoStatus(
    device: nvmlDevice_t,
    adaptiveClockStatus: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetBusType(
    device: nvmlDevice_t,
    type_: *mut nvmlBusType_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuFabricInfo(
    device: nvmlDevice_t,
    gpuFabricInfo: *mut nvmlGpuFabricInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetConfComputeCapabilities(
    capabilities: *mut nvmlConfComputeSystemCaps_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetConfComputeState(
    state: *mut nvmlConfComputeSystemState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetConfComputeMemSizeInfo(
    device: nvmlDevice_t,
    memInfo: *mut nvmlConfComputeMemSizeInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetConfComputeGpusReadyState(
    isAcceptingWork: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetConfComputeProtectedMemoryUsage(
    device: nvmlDevice_t,
    memory: *mut nvmlMemory_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetConfComputeGpuCertificate(
    device: nvmlDevice_t,
    gpuCert: *mut nvmlConfComputeGpuCertificate_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetConfComputeGpuAttestationReport(
    device: nvmlDevice_t,
    gpuAtstReport: *mut nvmlConfComputeGpuAttestationReport_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAccountingMode(
    device: nvmlDevice_t,
    mode: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAccountingStats(
    device: nvmlDevice_t,
    pid: ::std::os::raw::c_uint,
    stats: *mut nvmlAccountingStats_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAccountingPids(
    device: nvmlDevice_t,
    count: *mut ::std::os::raw::c_uint,
    pids: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAccountingBufferSize(
    device: nvmlDevice_t,
    bufferSize: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetRetiredPages(
    device: nvmlDevice_t,
    cause: nvmlPageRetirementCause_t,
    pageCount: *mut ::std::os::raw::c_uint,
    addresses: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetRetiredPages_v2(
    device: nvmlDevice_t,
    cause: nvmlPageRetirementCause_t,
    pageCount: *mut ::std::os::raw::c_uint,
    addresses: *mut ::std::os::raw::c_ulonglong,
    timestamps: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetRetiredPagesPendingStatus(
    device: nvmlDevice_t,
    isPending: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetRemappedRows(
    device: nvmlDevice_t,
    corrRows: *mut ::std::os::raw::c_uint,
    uncRows: *mut ::std::os::raw::c_uint,
    isPending: *mut ::std::os::raw::c_uint,
    failureOccurred: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetRowRemapperHistogram(
    device: nvmlDevice_t,
    values: *mut nvmlRowRemapperHistogramValues_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetArchitecture(
    device: nvmlDevice_t,
    arch: *mut nvmlDeviceArchitecture_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitSetLedState(unit: nvmlUnit_t, color: nvmlLedColor_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetPersistenceMode(
    device: nvmlDevice_t,
    mode: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetComputeMode(
    device: nvmlDevice_t,
    mode: nvmlComputeMode_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetEccMode(
    device: nvmlDevice_t,
    ecc: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceClearEccErrorCounts(
    device: nvmlDevice_t,
    counterType: nvmlEccCounterType_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetDriverModel(
    device: nvmlDevice_t,
    driverModel: nvmlDriverModel_t,
    flags: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetGpuLockedClocks(
    device: nvmlDevice_t,
    minGpuClockMHz: ::std::os::raw::c_uint,
    maxGpuClockMHz: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceResetGpuLockedClocks(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetMemoryLockedClocks(
    device: nvmlDevice_t,
    minMemClockMHz: ::std::os::raw::c_uint,
    maxMemClockMHz: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceResetMemoryLockedClocks(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetApplicationsClocks(
    device: nvmlDevice_t,
    memClockMHz: ::std::os::raw::c_uint,
    graphicsClockMHz: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetClkMonStatus(
    device: nvmlDevice_t,
    status: *mut nvmlClkMonStatus_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetPowerManagementLimit(
    device: nvmlDevice_t,
    limit: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetGpuOperationMode(
    device: nvmlDevice_t,
    mode: nvmlGpuOperationMode_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetAPIRestriction(
    device: nvmlDevice_t,
    apiType: nvmlRestrictedAPI_t,
    isRestricted: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetFanSpeed_v2(
    device: nvmlDevice_t,
    fan: ::std::os::raw::c_uint,
    speed: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetGpcClkVfOffset(
    device: nvmlDevice_t,
    offset: ::std::os::raw::c_int,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetMemClkVfOffset(
    device: nvmlDevice_t,
    offset: ::std::os::raw::c_int,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetConfComputeUnprotectedMemSize(
    device: nvmlDevice_t,
    sizeKiB: ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemSetConfComputeGpusReadyState(
    isAcceptingWork: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetAccountingMode(
    device: nvmlDevice_t,
    mode: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceClearAccountingPids(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkState(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    isActive: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    unsafe { crate::common::device_get_nvlink_state(device, link, isActive) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkVersion(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    version: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkCapability(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    capability: nvmlNvLinkCapability_t,
    capResult: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkRemotePciInfo_v2(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    pci: *mut nvmlPciInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkErrorCounter(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    counter: nvmlNvLinkErrorCounter_t,
    counterValue: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceResetNvLinkErrorCounters(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetNvLinkUtilizationControl(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    counter: ::std::os::raw::c_uint,
    control: *mut nvmlNvLinkUtilizationControl_t,
    reset: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkUtilizationControl(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    counter: ::std::os::raw::c_uint,
    control: *mut nvmlNvLinkUtilizationControl_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkUtilizationCounter(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    counter: ::std::os::raw::c_uint,
    rxcounter: *mut ::std::os::raw::c_ulonglong,
    txcounter: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceFreezeNvLinkUtilizationCounter(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    counter: ::std::os::raw::c_uint,
    freeze: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceResetNvLinkUtilizationCounter(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    counter: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkRemoteDeviceType(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    pNvLinkDeviceType: *mut nvmlIntNvLinkDeviceType_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlEventSetCreate(set: *mut nvmlEventSet_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceRegisterEvents(
    device: nvmlDevice_t,
    eventTypes: ::std::os::raw::c_ulonglong,
    set: nvmlEventSet_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSupportedEventTypes(
    device: nvmlDevice_t,
    eventTypes: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlEventSetWait_v2(
    set: nvmlEventSet_t,
    data: *mut nvmlEventData_t,
    timeoutms: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlEventSetFree(set: nvmlEventSet_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceModifyDrainState(
    pciInfo: *mut nvmlPciInfo_t,
    newState: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceQueryDrainState(
    pciInfo: *mut nvmlPciInfo_t,
    currentState: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceRemoveGpu_v2(
    pciInfo: *mut nvmlPciInfo_t,
    gpuState: nvmlDetachGpuState_t,
    linkState: nvmlPcieLinkState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceDiscoverGpus(pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub unsafe extern "C" fn nvmlDeviceGetFieldValues(
    device: nvmlDevice_t,
    valuesCount: ::std::os::raw::c_int,
    values: *mut nvmlFieldValue_t,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_field_values(device, valuesCount, values) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceClearFieldValues(
    device: nvmlDevice_t,
    valuesCount: ::std::os::raw::c_int,
    values: *mut nvmlFieldValue_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVirtualizationMode(
    device: nvmlDevice_t,
    pVirtualMode: *mut nvmlGpuVirtualizationMode_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetHostVgpuMode(
    device: nvmlDevice_t,
    pHostVgpuMode: *mut nvmlHostVgpuMode_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetVirtualizationMode(
    device: nvmlDevice_t,
    virtualMode: nvmlGpuVirtualizationMode_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGridLicensableFeatures_v4(
    device: nvmlDevice_t,
    pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetProcessUtilization(
    device: nvmlDevice_t,
    utilization: *mut nvmlProcessUtilizationSample_t,
    processSamplesCount: *mut ::std::os::raw::c_uint,
    lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGspFirmwareVersion(
    device: nvmlDevice_t,
    version: *mut ::std::os::raw::c_char,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGspFirmwareMode(
    device: nvmlDevice_t,
    isEnabled: *mut ::std::os::raw::c_uint,
    defaultMode: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGetVgpuDriverCapabilities(
    capability: nvmlVgpuDriverCapability_t,
    capResult: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVgpuCapabilities(
    device: nvmlDevice_t,
    capability: nvmlDeviceVgpuCapability_t,
    capResult: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSupportedVgpus(
    device: nvmlDevice_t,
    vgpuCount: *mut ::std::os::raw::c_uint,
    vgpuTypeIds: *mut nvmlVgpuTypeId_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCreatableVgpus(
    device: nvmlDevice_t,
    vgpuCount: *mut ::std::os::raw::c_uint,
    vgpuTypeIds: *mut nvmlVgpuTypeId_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetClass(
    vgpuTypeId: nvmlVgpuTypeId_t,
    vgpuTypeClass: *mut ::std::os::raw::c_char,
    size: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetName(
    vgpuTypeId: nvmlVgpuTypeId_t,
    vgpuTypeName: *mut ::std::os::raw::c_char,
    size: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetGpuInstanceProfileId(
    vgpuTypeId: nvmlVgpuTypeId_t,
    gpuInstanceProfileId: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetDeviceID(
    vgpuTypeId: nvmlVgpuTypeId_t,
    deviceID: *mut ::std::os::raw::c_ulonglong,
    subsystemID: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetFramebufferSize(
    vgpuTypeId: nvmlVgpuTypeId_t,
    fbSize: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetNumDisplayHeads(
    vgpuTypeId: nvmlVgpuTypeId_t,
    numDisplayHeads: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetResolution(
    vgpuTypeId: nvmlVgpuTypeId_t,
    displayIndex: ::std::os::raw::c_uint,
    xdim: *mut ::std::os::raw::c_uint,
    ydim: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetLicense(
    vgpuTypeId: nvmlVgpuTypeId_t,
    vgpuTypeLicenseString: *mut ::std::os::raw::c_char,
    size: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetFrameRateLimit(
    vgpuTypeId: nvmlVgpuTypeId_t,
    frameRateLimit: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetMaxInstances(
    device: nvmlDevice_t,
    vgpuTypeId: nvmlVgpuTypeId_t,
    vgpuInstanceCount: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetMaxInstancesPerVm(
    vgpuTypeId: nvmlVgpuTypeId_t,
    vgpuInstanceCountPerVm: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetActiveVgpus(
    device: nvmlDevice_t,
    vgpuCount: *mut ::std::os::raw::c_uint,
    vgpuInstances: *mut nvmlVgpuInstance_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetVmID(
    vgpuInstance: nvmlVgpuInstance_t,
    vmId: *mut ::std::os::raw::c_char,
    size: ::std::os::raw::c_uint,
    vmIdType: *mut nvmlVgpuVmIdType_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetUUID(
    vgpuInstance: nvmlVgpuInstance_t,
    uuid: *mut ::std::os::raw::c_char,
    size: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetVmDriverVersion(
    vgpuInstance: nvmlVgpuInstance_t,
    version: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetFbUsage(
    vgpuInstance: nvmlVgpuInstance_t,
    fbUsage: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetLicenseStatus(
    vgpuInstance: nvmlVgpuInstance_t,
    licensed: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetType(
    vgpuInstance: nvmlVgpuInstance_t,
    vgpuTypeId: *mut nvmlVgpuTypeId_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetFrameRateLimit(
    vgpuInstance: nvmlVgpuInstance_t,
    frameRateLimit: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetEccMode(
    vgpuInstance: nvmlVgpuInstance_t,
    eccMode: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetEncoderCapacity(
    vgpuInstance: nvmlVgpuInstance_t,
    encoderCapacity: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceSetEncoderCapacity(
    vgpuInstance: nvmlVgpuInstance_t,
    encoderCapacity: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetEncoderStats(
    vgpuInstance: nvmlVgpuInstance_t,
    sessionCount: *mut ::std::os::raw::c_uint,
    averageFps: *mut ::std::os::raw::c_uint,
    averageLatency: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetEncoderSessions(
    vgpuInstance: nvmlVgpuInstance_t,
    sessionCount: *mut ::std::os::raw::c_uint,
    sessionInfo: *mut nvmlEncoderSessionInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetFBCStats(
    vgpuInstance: nvmlVgpuInstance_t,
    fbcStats: *mut nvmlFBCStats_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetFBCSessions(
    vgpuInstance: nvmlVgpuInstance_t,
    sessionCount: *mut ::std::os::raw::c_uint,
    sessionInfo: *mut nvmlFBCSessionInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetGpuInstanceId(
    vgpuInstance: nvmlVgpuInstance_t,
    gpuInstanceId: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetGpuPciId(
    vgpuInstance: nvmlVgpuInstance_t,
    vgpuPciId: *mut ::std::os::raw::c_char,
    length: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetCapabilities(
    vgpuTypeId: nvmlVgpuTypeId_t,
    capability: nvmlVgpuCapability_t,
    capResult: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuVersion_st {
    pub minVersion: ::std::os::raw::c_uint,
    pub maxVersion: ::std::os::raw::c_uint,
}
pub type nvmlVgpuVersion_t = nvmlVgpuVersion_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuMetadata_st {
    pub version: ::std::os::raw::c_uint,
    pub revision: ::std::os::raw::c_uint,
    pub guestInfoState: nvmlVgpuGuestInfoState_t,
    pub guestDriverVersion: [::std::os::raw::c_char; 80usize],
    pub hostDriverVersion: [::std::os::raw::c_char; 80usize],
    pub reserved: [::std::os::raw::c_uint; 6usize],
    pub vgpuVirtualizationCaps: ::std::os::raw::c_uint,
    pub guestVgpuVersion: ::std::os::raw::c_uint,
    pub opaqueDataSize: ::std::os::raw::c_uint,
    pub opaqueData: [::std::os::raw::c_char; 4usize],
}
pub type nvmlVgpuMetadata_t = nvmlVgpuMetadata_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuPgpuMetadata_st {
    pub version: ::std::os::raw::c_uint,
    pub revision: ::std::os::raw::c_uint,
    pub hostDriverVersion: [::std::os::raw::c_char; 80usize],
    pub pgpuVirtualizationCaps: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 5usize],
    pub hostSupportedVgpuRange: nvmlVgpuVersion_t,
    pub opaqueDataSize: ::std::os::raw::c_uint,
    pub opaqueData: [::std::os::raw::c_char; 4usize],
}
pub type nvmlVgpuPgpuMetadata_t = nvmlVgpuPgpuMetadata_st;
impl nvmlVgpuVmCompatibility_enum {
    pub const NVML_VGPU_VM_COMPATIBILITY_NONE: nvmlVgpuVmCompatibility_enum =
        nvmlVgpuVmCompatibility_enum(0);
}
impl nvmlVgpuVmCompatibility_enum {
    pub const NVML_VGPU_VM_COMPATIBILITY_COLD: nvmlVgpuVmCompatibility_enum =
        nvmlVgpuVmCompatibility_enum(1);
}
impl nvmlVgpuVmCompatibility_enum {
    pub const NVML_VGPU_VM_COMPATIBILITY_HIBERNATE: nvmlVgpuVmCompatibility_enum =
        nvmlVgpuVmCompatibility_enum(2);
}
impl nvmlVgpuVmCompatibility_enum {
    pub const NVML_VGPU_VM_COMPATIBILITY_SLEEP: nvmlVgpuVmCompatibility_enum =
        nvmlVgpuVmCompatibility_enum(4);
}
impl nvmlVgpuVmCompatibility_enum {
    pub const NVML_VGPU_VM_COMPATIBILITY_LIVE: nvmlVgpuVmCompatibility_enum =
        nvmlVgpuVmCompatibility_enum(8);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlVgpuVmCompatibility_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlVgpuVmCompatibility_enum as nvmlVgpuVmCompatibility_t;
impl nvmlVgpuPgpuCompatibilityLimitCode_enum {
    pub const NVML_VGPU_COMPATIBILITY_LIMIT_NONE: nvmlVgpuPgpuCompatibilityLimitCode_enum =
        nvmlVgpuPgpuCompatibilityLimitCode_enum(0);
}
impl nvmlVgpuPgpuCompatibilityLimitCode_enum {
    pub const NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER: nvmlVgpuPgpuCompatibilityLimitCode_enum =
        nvmlVgpuPgpuCompatibilityLimitCode_enum(1);
}
impl nvmlVgpuPgpuCompatibilityLimitCode_enum {
    pub const NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER: nvmlVgpuPgpuCompatibilityLimitCode_enum =
        nvmlVgpuPgpuCompatibilityLimitCode_enum(2);
}
impl nvmlVgpuPgpuCompatibilityLimitCode_enum {
    pub const NVML_VGPU_COMPATIBILITY_LIMIT_GPU: nvmlVgpuPgpuCompatibilityLimitCode_enum =
        nvmlVgpuPgpuCompatibilityLimitCode_enum(4);
}
impl nvmlVgpuPgpuCompatibilityLimitCode_enum {
    pub const NVML_VGPU_COMPATIBILITY_LIMIT_OTHER: nvmlVgpuPgpuCompatibilityLimitCode_enum =
        nvmlVgpuPgpuCompatibilityLimitCode_enum(2147483648);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlVgpuPgpuCompatibilityLimitCode_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlVgpuPgpuCompatibilityLimitCode_enum as nvmlVgpuPgpuCompatibilityLimitCode_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuPgpuCompatibility_st {
    pub vgpuVmCompatibility: nvmlVgpuVmCompatibility_t,
    pub compatibilityLimitCode: nvmlVgpuPgpuCompatibilityLimitCode_t,
}
pub type nvmlVgpuPgpuCompatibility_t = nvmlVgpuPgpuCompatibility_st;

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetMetadata(
    vgpuInstance: nvmlVgpuInstance_t,
    vgpuMetadata: *mut nvmlVgpuMetadata_t,
    bufferSize: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVgpuMetadata(
    device: nvmlDevice_t,
    pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
    bufferSize: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGetVgpuCompatibility(
    vgpuMetadata: *mut nvmlVgpuMetadata_t,
    pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
    compatibilityInfo: *mut nvmlVgpuPgpuCompatibility_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPgpuMetadataString(
    device: nvmlDevice_t,
    pgpuMetadata: *mut ::std::os::raw::c_char,
    bufferSize: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVgpuSchedulerLog(
    device: nvmlDevice_t,
    pSchedulerLog: *mut nvmlVgpuSchedulerLog_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVgpuSchedulerState(
    device: nvmlDevice_t,
    pSchedulerState: *mut nvmlVgpuSchedulerGetState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVgpuSchedulerCapabilities(
    device: nvmlDevice_t,
    pCapabilities: *mut nvmlVgpuSchedulerCapabilities_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetVgpuSchedulerState(
    device: nvmlDevice_t,
    pSchedulerState: *mut nvmlVgpuSchedulerSetState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGetVgpuVersion(
    supported: *mut nvmlVgpuVersion_t,
    current: *mut nvmlVgpuVersion_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSetVgpuVersion(vgpuVersion: *mut nvmlVgpuVersion_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVgpuUtilization(
    device: nvmlDevice_t,
    lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
    sampleValType: *mut nvmlValueType_t,
    vgpuInstanceSamplesCount: *mut ::std::os::raw::c_uint,
    utilizationSamples: *mut nvmlVgpuInstanceUtilizationSample_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVgpuProcessUtilization(
    device: nvmlDevice_t,
    lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
    vgpuProcessSamplesCount: *mut ::std::os::raw::c_uint,
    utilizationSamples: *mut nvmlVgpuProcessUtilizationSample_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetAccountingMode(
    vgpuInstance: nvmlVgpuInstance_t,
    mode: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetAccountingPids(
    vgpuInstance: nvmlVgpuInstance_t,
    count: *mut ::std::os::raw::c_uint,
    pids: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetAccountingStats(
    vgpuInstance: nvmlVgpuInstance_t,
    pid: ::std::os::raw::c_uint,
    stats: *mut nvmlAccountingStats_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceClearAccountingPids(
    vgpuInstance: nvmlVgpuInstance_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetLicenseInfo_v2(
    vgpuInstance: nvmlVgpuInstance_t,
    licenseInfo: *mut nvmlVgpuLicenseInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlExcludedDeviceInfo_st {
    pub pciInfo: nvmlPciInfo_t,
    pub uuid: [::std::os::raw::c_char; 80usize],
}
pub type nvmlExcludedDeviceInfo_t = nvmlExcludedDeviceInfo_st;

#[no_mangle]
pub extern "C" fn nvmlGetExcludedDeviceCount(
    deviceCount: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGetExcludedDeviceInfoByIndex(
    index: ::std::os::raw::c_uint,
    info: *mut nvmlExcludedDeviceInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuInstancePlacement_st {
    pub start: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
}
pub type nvmlGpuInstancePlacement_t = nvmlGpuInstancePlacement_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuInstanceProfileInfo_st {
    pub id: ::std::os::raw::c_uint,
    pub isP2pSupported: ::std::os::raw::c_uint,
    pub sliceCount: ::std::os::raw::c_uint,
    pub instanceCount: ::std::os::raw::c_uint,
    pub multiprocessorCount: ::std::os::raw::c_uint,
    pub copyEngineCount: ::std::os::raw::c_uint,
    pub decoderCount: ::std::os::raw::c_uint,
    pub encoderCount: ::std::os::raw::c_uint,
    pub jpegCount: ::std::os::raw::c_uint,
    pub ofaCount: ::std::os::raw::c_uint,
    pub memorySizeMB: ::std::os::raw::c_ulonglong,
}
pub type nvmlGpuInstanceProfileInfo_t = nvmlGpuInstanceProfileInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuInstanceProfileInfo_v2_st {
    pub version: ::std::os::raw::c_uint,
    pub id: ::std::os::raw::c_uint,
    pub isP2pSupported: ::std::os::raw::c_uint,
    pub sliceCount: ::std::os::raw::c_uint,
    pub instanceCount: ::std::os::raw::c_uint,
    pub multiprocessorCount: ::std::os::raw::c_uint,
    pub copyEngineCount: ::std::os::raw::c_uint,
    pub decoderCount: ::std::os::raw::c_uint,
    pub encoderCount: ::std::os::raw::c_uint,
    pub jpegCount: ::std::os::raw::c_uint,
    pub ofaCount: ::std::os::raw::c_uint,
    pub memorySizeMB: ::std::os::raw::c_ulonglong,
    pub name: [::std::os::raw::c_char; 96usize],
}
pub type nvmlGpuInstanceProfileInfo_v2_t = nvmlGpuInstanceProfileInfo_v2_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuInstanceInfo_st {
    pub device: nvmlDevice_t,
    pub id: ::std::os::raw::c_uint,
    pub profileId: ::std::os::raw::c_uint,
    pub placement: nvmlGpuInstancePlacement_t,
}
pub type nvmlGpuInstanceInfo_t = nvmlGpuInstanceInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuInstance_st {
    _unused: [u8; 0],
}
pub type nvmlGpuInstance_t = *mut nvmlGpuInstance_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlComputeInstancePlacement_st {
    pub start: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
}
pub type nvmlComputeInstancePlacement_t = nvmlComputeInstancePlacement_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlComputeInstanceProfileInfo_st {
    pub id: ::std::os::raw::c_uint,
    pub sliceCount: ::std::os::raw::c_uint,
    pub instanceCount: ::std::os::raw::c_uint,
    pub multiprocessorCount: ::std::os::raw::c_uint,
    pub sharedCopyEngineCount: ::std::os::raw::c_uint,
    pub sharedDecoderCount: ::std::os::raw::c_uint,
    pub sharedEncoderCount: ::std::os::raw::c_uint,
    pub sharedJpegCount: ::std::os::raw::c_uint,
    pub sharedOfaCount: ::std::os::raw::c_uint,
}
pub type nvmlComputeInstanceProfileInfo_t = nvmlComputeInstanceProfileInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlComputeInstanceProfileInfo_v2_st {
    pub version: ::std::os::raw::c_uint,
    pub id: ::std::os::raw::c_uint,
    pub sliceCount: ::std::os::raw::c_uint,
    pub instanceCount: ::std::os::raw::c_uint,
    pub multiprocessorCount: ::std::os::raw::c_uint,
    pub sharedCopyEngineCount: ::std::os::raw::c_uint,
    pub sharedDecoderCount: ::std::os::raw::c_uint,
    pub sharedEncoderCount: ::std::os::raw::c_uint,
    pub sharedJpegCount: ::std::os::raw::c_uint,
    pub sharedOfaCount: ::std::os::raw::c_uint,
    pub name: [::std::os::raw::c_char; 96usize],
}
pub type nvmlComputeInstanceProfileInfo_v2_t = nvmlComputeInstanceProfileInfo_v2_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlComputeInstanceInfo_st {
    pub device: nvmlDevice_t,
    pub gpuInstance: nvmlGpuInstance_t,
    pub id: ::std::os::raw::c_uint,
    pub profileId: ::std::os::raw::c_uint,
    pub placement: nvmlComputeInstancePlacement_t,
}
pub type nvmlComputeInstanceInfo_t = nvmlComputeInstanceInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlComputeInstance_st {
    _unused: [u8; 0],
}
pub type nvmlComputeInstance_t = *mut nvmlComputeInstance_st;

#[no_mangle]
pub extern "C" fn nvmlDeviceSetMigMode(
    device: nvmlDevice_t,
    mode: ::std::os::raw::c_uint,
    activationStatus: *mut nvmlReturn_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMigMode(
    device: nvmlDevice_t,
    currentMode: *mut ::std::os::raw::c_uint,
    pendingMode: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstanceProfileInfo(
    device: nvmlDevice_t,
    profile: ::std::os::raw::c_uint,
    info: *mut nvmlGpuInstanceProfileInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstanceProfileInfoV(
    device: nvmlDevice_t,
    profile: ::std::os::raw::c_uint,
    info: *mut nvmlGpuInstanceProfileInfo_v2_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstancePossiblePlacements_v2(
    device: nvmlDevice_t,
    profileId: ::std::os::raw::c_uint,
    placements: *mut nvmlGpuInstancePlacement_t,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstanceRemainingCapacity(
    device: nvmlDevice_t,
    profileId: ::std::os::raw::c_uint,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceCreateGpuInstance(
    device: nvmlDevice_t,
    profileId: ::std::os::raw::c_uint,
    gpuInstance: *mut nvmlGpuInstance_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceCreateGpuInstanceWithPlacement(
    device: nvmlDevice_t,
    profileId: ::std::os::raw::c_uint,
    placement: *const nvmlGpuInstancePlacement_t,
    gpuInstance: *mut nvmlGpuInstance_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceDestroy(gpuInstance: nvmlGpuInstance_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstances(
    device: nvmlDevice_t,
    profileId: ::std::os::raw::c_uint,
    gpuInstances: *mut nvmlGpuInstance_t,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstanceById(
    device: nvmlDevice_t,
    id: ::std::os::raw::c_uint,
    gpuInstance: *mut nvmlGpuInstance_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceGetInfo(
    gpuInstance: nvmlGpuInstance_t,
    info: *mut nvmlGpuInstanceInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceGetComputeInstanceProfileInfo(
    gpuInstance: nvmlGpuInstance_t,
    profile: ::std::os::raw::c_uint,
    engProfile: ::std::os::raw::c_uint,
    info: *mut nvmlComputeInstanceProfileInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceGetComputeInstanceProfileInfoV(
    gpuInstance: nvmlGpuInstance_t,
    profile: ::std::os::raw::c_uint,
    engProfile: ::std::os::raw::c_uint,
    info: *mut nvmlComputeInstanceProfileInfo_v2_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceGetComputeInstanceRemainingCapacity(
    gpuInstance: nvmlGpuInstance_t,
    profileId: ::std::os::raw::c_uint,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceGetComputeInstancePossiblePlacements(
    gpuInstance: nvmlGpuInstance_t,
    profileId: ::std::os::raw::c_uint,
    placements: *mut nvmlComputeInstancePlacement_t,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceCreateComputeInstance(
    gpuInstance: nvmlGpuInstance_t,
    profileId: ::std::os::raw::c_uint,
    computeInstance: *mut nvmlComputeInstance_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceCreateComputeInstanceWithPlacement(
    gpuInstance: nvmlGpuInstance_t,
    profileId: ::std::os::raw::c_uint,
    placement: *const nvmlComputeInstancePlacement_t,
    computeInstance: *mut nvmlComputeInstance_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlComputeInstanceDestroy(
    computeInstance: nvmlComputeInstance_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceGetComputeInstances(
    gpuInstance: nvmlGpuInstance_t,
    profileId: ::std::os::raw::c_uint,
    computeInstances: *mut nvmlComputeInstance_t,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceGetComputeInstanceById(
    gpuInstance: nvmlGpuInstance_t,
    id: ::std::os::raw::c_uint,
    computeInstance: *mut nvmlComputeInstance_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlComputeInstanceGetInfo_v2(
    computeInstance: nvmlComputeInstance_t,
    info: *mut nvmlComputeInstanceInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceIsMigDeviceHandle(
    device: nvmlDevice_t,
    isMigDevice: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstanceId(
    device: nvmlDevice_t,
    id: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetComputeInstanceId(
    device: nvmlDevice_t,
    id: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMaxMigDeviceCount(
    device: nvmlDevice_t,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMigDeviceHandleByIndex(
    device: nvmlDevice_t,
    index: ::std::os::raw::c_uint,
    migDevice: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDeviceHandleFromMigDeviceHandle(
    migDevice: nvmlDevice_t,
    device: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpmSample_st {
    _unused: [u8; 0],
}
pub type nvmlGpmSample_t = *mut nvmlGpmSample_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpmMetric_t {
    pub metricId: ::std::os::raw::c_uint,
    pub nvmlReturn: nvmlReturn_t,
    pub value: f64,
    pub metricInfo: nvmlGpmMetric_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpmMetric_t__bindgen_ty_1 {
    pub shortName: *mut ::std::os::raw::c_char,
    pub longName: *mut ::std::os::raw::c_char,
    pub unit: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpmMetricsGet_t {
    pub version: ::std::os::raw::c_uint,
    pub numMetrics: ::std::os::raw::c_uint,
    pub sample1: nvmlGpmSample_t,
    pub sample2: nvmlGpmSample_t,
    pub metrics: [nvmlGpmMetric_t; 98usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpmSupport_t {
    pub version: ::std::os::raw::c_uint,
    pub isSupportedDevice: ::std::os::raw::c_uint,
}

#[no_mangle]
pub extern "C" fn nvmlGpmMetricsGet(metricsGet: *mut nvmlGpmMetricsGet_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpmSampleFree(gpmSample: nvmlGpmSample_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpmSampleAlloc(gpmSample: *mut nvmlGpmSample_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpmSampleGet(
    device: nvmlDevice_t,
    gpmSample: nvmlGpmSample_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpmMigSampleGet(
    device: nvmlDevice_t,
    gpuInstanceId: ::std::os::raw::c_uint,
    gpmSample: nvmlGpmSample_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpmQueryDeviceSupport(
    device: nvmlDevice_t,
    gpmSupport: *mut nvmlGpmSupport_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpmQueryIfStreamingEnabled(
    device: nvmlDevice_t,
    state: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpmSetStreamingEnabled(
    device: nvmlDevice_t,
    state: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlNvLinkPowerThres_st {
    pub lowPwrThreshold: ::std::os::raw::c_uint,
}
pub type nvmlNvLinkPowerThres_t = nvmlNvLinkPowerThres_st;

#[no_mangle]
pub extern "C" fn nvmlDeviceSetNvLinkDeviceLowPowerThreshold(
    device: nvmlDevice_t,
    info: *mut nvmlNvLinkPowerThres_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemSetNvlinkBwMode(nvlinkBwMode: ::std::os::raw::c_uint) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetNvlinkBwMode(
    nvlinkBwMode: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetPowerManagementLimit_v2(
    device: nvmlDevice_t,
    powerValue: *mut nvmlPowerValue_v2_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlInit() -> nvmlReturn_t {
    unsafe { crate::r#impl::init().into() }
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCount(deviceCount: *mut ::std::os::raw::c_uint) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_count(deviceCount) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetHandleByIndex(
    index: ::std::os::raw::c_uint,
    device: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_handle_by_index(index, device) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetHandleByPciBusId(
    pciBusId: *const ::std::os::raw::c_char,
    device: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_handle_by_pci_bus_id(pciBusId, device) }.into()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPciInfo(
    device: nvmlDevice_t,
    pci: *mut nvmlPciInfo_t,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_pci_info(device, pci).into() }
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPciInfo_v2(
    device: nvmlDevice_t,
    pci: *mut nvmlPciInfo_t,
) -> nvmlReturn_t {
    unsafe { crate::r#impl::device_get_pci_info(device, pci).into() }
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkRemotePciInfo(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    pci: *mut nvmlPciInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGridLicensableFeatures(
    device: nvmlDevice_t,
    pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGridLicensableFeatures_v2(
    device: nvmlDevice_t,
    pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGridLicensableFeatures_v3(
    device: nvmlDevice_t,
    pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceRemoveGpu(pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlEventSetWait(
    set: nvmlEventSet_t,
    data: *mut nvmlEventData_t,
    timeoutms: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAttributes(
    device: nvmlDevice_t,
    attributes: *mut nvmlDeviceAttributes_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlComputeInstanceGetInfo(
    computeInstance: nvmlComputeInstance_t,
    info: *mut nvmlComputeInstanceInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetComputeRunningProcesses(
    device: nvmlDevice_t,
    infoCount: *mut ::std::os::raw::c_uint,
    infos: *mut nvmlProcessInfo_v1_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetComputeRunningProcesses_v2(
    device: nvmlDevice_t,
    infoCount: *mut ::std::os::raw::c_uint,
    infos: *mut nvmlProcessInfo_v2_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGraphicsRunningProcesses(
    device: nvmlDevice_t,
    infoCount: *mut ::std::os::raw::c_uint,
    infos: *mut nvmlProcessInfo_v1_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGraphicsRunningProcesses_v2(
    device: nvmlDevice_t,
    infoCount: *mut ::std::os::raw::c_uint,
    infos: *mut nvmlProcessInfo_v2_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMPSComputeRunningProcesses(
    device: nvmlDevice_t,
    infoCount: *mut ::std::os::raw::c_uint,
    infos: *mut nvmlProcessInfo_v1_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMPSComputeRunningProcesses_v2(
    device: nvmlDevice_t,
    infoCount: *mut ::std::os::raw::c_uint,
    infos: *mut nvmlProcessInfo_v2_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstancePossiblePlacements(
    device: nvmlDevice_t,
    profileId: ::std::os::raw::c_uint,
    placements: *mut nvmlGpuInstancePlacement_t,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetLicenseInfo(
    vgpuInstance: nvmlVgpuInstance_t,
    licenseInfo: *mut nvmlVgpuLicenseInfo_t,
) -> nvmlReturn_t {
    crate::common::unimplemented()
}
